{
    "general": {
        "title": "Problema comis-voiajorului"
        , "theorem": "TeoremÄƒ"
        , "complexity": "Complexitate"
        , "explications": "ExplicaÈ›ii pe cod"
        , "definition": "DefiniÈ›ie"
        , "definitions": "DefiniÈ›ii"
        , "example": "Exemplu"
        , "algorithm": "Algoritm"
        , "step-by-step-example": "Exemplu pas cu pas"
        , "languages": {
            "ro": "RomÃ¢nÄƒ"
            , "en": "EnglezÄƒ"
        }
        , "construction": "Construire"
    },
    "about-tsp": {
        "header-name-problem": "\t Problema comis-voiajorului (prescurtat TSP)"
        ,"header": " este una dintre cele mai cunoscute probleme computaÈ›ionale de optimizare, o problemÄƒ de interes datoritÄƒ faptului cÄƒ este Ã®ntÃ¢lnitÄƒ Ã®n practicÄƒ sub diverse forme. Are o istorie lungÄƒ de Ã®ncercÄƒri de a o rezolva, gÄƒsirea unui algoritm cÃ¢t mai eficient chiar dacÄƒ vom vedea cÄƒ este foarte posibil sÄƒ nu se poatÄƒ crea un algoritm care sÄƒ ofere o soluÈ›ie Ã®n timp polinomial, fiind demonstrat faptul cÄƒ problema este NP-completÄƒ. "
        
        ,"title": "Prezentarea problemei"
        , "problem-explication": "\t TSP presupune gÄƒsirea rutei optime prin care comis-voiajorul poate vizita n oraÈ™e, trecÃ¢nd prin fiecare o singurÄƒ datÄƒ È™i Ã®ntorcÃ¢ndu-se la final Ã®n oraÈ™ul de unde a plecat. Se poate considera ca ruta optimÄƒ distanÈ›a minimÄƒ sau costul minin al drumului (problema nu se schimbÄƒ)."
        , "definition-graph": "\t Fie G = (V,E) un graf neorientat pentru care V este mulÈ›imea nodurilor (oraÈ™elor), E este mulÈ›imea muchiilor Ã®ntre noduri (drumurilor dintre oraÈ™e) È™i fiecare muchie are propria lungime cu condiÈ›ia ca ponderea sÄƒ fie ne-negativÄƒ. Un graf neorientat ponderat poate fi privit ca fiind complet creÃ¢nd muchii fictive Ã®ntre nodurile neadiacente de lungime infinit." 
        , "definition-matrix": "\t Orice graf ponderat se poate memora cu ajutorul matricei de distanÈ›Äƒ D de dimensiune (n x n) unde pentru fiecare i È™i j  avem  d(i, j) = lungimea muchiei(i, j). DistanÈ›a de la un nod la sine este definitÄƒ a fi zero (d(i, i) = 0 pentru orice i âˆˆ V). Ãn algoritmii descriÈ™i Ã®n capitolele urmÄƒtoare, vom prefera sÄƒ considerÄƒm d(i, i) = âˆ pentru a elimina nevoia de a testa cÄƒ vÃ¢rfurile curente sunt distincte."
        , "hamiltonain-cycle": {
            "title": "Prezentarea noÈ›iunii de ciclu hamiltonian È™i introducerea Ã®n problema comis-voiajorului"
            , "cycle": "Un ciclu hamiltonian Ã®ntr-un graf complet G este o permutare ciclicÄƒ (1,Ï€(1), â€¦, Ï€^(n-1)(1)) pe mulÈ›imea nodurilor {1,...,n} din graf: 1 â†’Ï€(1) â†’ â‹¯ â†’ Ï€^(n-1)(1) â†’ 1. "
            , "minimum-cycle": "Un ciclu hamiltonian minim este un ciclu hamiltonian Ï€ astfel Ã®ncÃ¢t lungime totalÄƒ a ciclului este minimÄƒ:"
            , "cycle-length": "d(Ï€) = sum d({i,Ï€(i)}) cu i = {1, ..., n}"
            , "analogy-reference": "\t AÈ™adar problema TSP este urmÄƒtoarea:"
            , "analogy-definition": "dat un graf neorientat complet, sÄƒ se determine ciclul hamiltonian minim. "
            , "general-tsp": "AceastÄƒ formÄƒ a problemei poartÄƒ numele de problema comis-voiajorului simetricÄƒ, prescurtat sTSP, sau de TSP general."
            , "connectin-with-variations": {
                "text": "\t Alte variaÈ›ii ale problemei se gÄƒsesc Ã®n "
                , "linkText": "SecÈ›iunea VariaÈ›ii"
            }
        }
        , "general-tsp":{
            "title": "TSP general"
            , "definition-symmetric-matrix": "\t Graful fiind neorientat, d(i, j) = d(j, i) pentru orice i, j âˆˆ V, iar matricea este simetricÄƒ (egalÄƒ cu transpusa sa). Ãn analogie cu viaÈ›a realÄƒ, problema poate fi vÄƒzutÄƒ Ã®n felul urmÄƒtor: nodurile sunt destinaÈ›ii, iar muchiile sunt strÄƒzi cu specificaÈ›ia cÄƒ nu existÄƒ strÄƒzi cu sens unic (distanÈ›a este egalÄƒ indiferent de direcÈ›ia de mers). Se doreÈ™te drumul cel mai scurt."
            , "matrix": "Matricea corespunzÄƒtoare grafului"
            , "solution": "SoluÈ›ia optimÄƒ este 8 obÈ›inutÄƒ de drumul 0 -> 1 -> 2 -> 3 -> 0."
        } 
        , "np-completeness": {
            "title": "NP-completitudinea problemei TSP"
            , "definition-1": {
                "part-1": "\t O problemÄƒ se numeÈ™te "
                , "part-2": "problemÄƒ de decizie "
                , "part-3": "dacÄƒ necesitÄƒ un rÄƒspuns logic, de tip true/false."
            }
            , "definition-2": {
                "part-1": "\t O problemÄƒ face parte din "
                , "part-2": " clasa de probleme P "
                , "part-3": " dacÄƒ existÄƒ un algoritm care oferÄƒ o soluÈ›ie Ã®n timp polinomial. "
                , "part-4": "Clasa NP "
                , "part-5": "este clasa de probleme care, Ã®n cazul Ã®n care se determinÄƒ o soluÈ›ie, se poate verifica Ã®n timp polinomial dacÄƒ soluÈ›ia este una corectÄƒ."
            }
            , "definition-3": {
                "part-1": "\t O problemÄƒ se numeÈ™te "
                , "part-2": "NP-completÄƒ "
                , "part-3": "dacÄƒ face parte din clasa NP È™i orice altÄƒ problemÄƒ din NP se reduce la ea."
            }
            ,"tsp-is-np": {
                "title": "TeoremÄƒ: TSP face parte din clasa de probleme NP."
                , "demonstration": "DemonstraÈ›ie"
                , "text": "\t TSP este o problemÄƒ de optimizare (dintre toate ciclurile hamiltoniane posibile Ã®ntre n oraÈ™e, se doreÈ™te ciclul hamiltonian de lungime minimÄƒ), dar poate fi redusÄƒ la o problemÄƒ de decizie pentru care, dÃ¢ndu-se un parametru ğ‘€ cu ğ‘€ âˆˆ ğ‘…+, se doreÈ™te sÄƒ se decidÄƒ dacÄƒ se poate determina o permutare a nodurilor astfel Ã®ncÃ¢t ğ‘‘(ğœ‹) â‰¤ ğ‘€. Problema Ã®n forma ei normalÄƒ este cel puÈ›in la fel de grea ca problema de decizie care Ã®i este asociatÄƒ. \n\t Mai departe, pe lÃ¢ngÄƒ rÄƒspunsul true sau false, se cere sÄƒ se ofere È™i un ciclu hamiltonian, pentru care se poate verifica Ã®n ğ‘‚(ğ‘›) dacÄƒ drumul determinat de noduri are lungime mai micÄƒ sau egalÄƒ cu ğ‘€. AÈ™adar, problema de decizie oferÄƒ È™i o soluÈ›ie pentru care poate fi verificat Ã®n timp polinomial corectitudinea rÄƒspunsului dat (dacÄƒ ğ‘‘(ğœ‹) â‰¤ ğ‘€). \n\t Prin urmare, TSP Ã®n forma de problemÄƒ de decizie este NP, deci È™i TSP este cel puÈ›in NP."
            }
            ,"tsp-is-np-complete": {
                "title": "TeoremÄƒ: TSP face parte din clasa de probleme NP-complete."
                , "demonstration": "DemonstraÈ›ie"
                , "text": "\t Ãn continuare considerÄƒm problema CH a determinÄƒrii unui ciclu hamiltonian care se È™tie cÄƒ este NP-completÄƒ È™i se demonstreazÄƒ pornind de la NP-completitudinea problemei comis voiajorului. Presupunem cÄƒ existÄƒ un algoritm polinomial care rezolvÄƒ TSP. \n\t Fie G = (V, E) un graf neorientat cÄƒruia Ã®i asociem un graf complet G' cu ponderile: d(i, j) = 1 dacÄƒ muchia (i, j) âˆˆ E, altfel d(i, j) = 2. \n\t Fie ğœ‹ soluÈ›ia TSP pentru graful ponderat obÈ›inut.\n\t\n\t ExistÄƒ Ã®n G un ciclu hamiltonian dacÄƒ È™i numai dacÄƒ Ã®n graful Gâ€™ ğ‘‘(ğœ‹)=ğ‘› deoarece, din definiÈ›ia TSP-ului, ğœ‹ este permutarea ciclicÄƒ de lungime minimÄƒ. \n\t Ãntr-adevÄƒr, dacÄƒ ğ‘‘(ğœ‹)=ğ‘›, ciclul ğœ‹ nu conÈ›ine nicio muchie de pondere 2, deci ğœ‹ se gÄƒseÈ™te È™i Ã®n graful iniÈ›ial G (G âŠ† Gâ€™) È™i este soluÈ›ie È™i pentru CH Ã®n G.\n\t Reciproc, dacÄƒ G are ciclul hamiltonian ğœ‹ acest ciclu ar avea cost n Ã®n Gâ€™ È™i ar fi soluÈ›ie pentru TSP deoarece nu conÈ›ine muchii de cost 2. \n\t AÈ™adar problema ciclului hamiltonian s-a redus la TSP, existenÈ›a unei soluÈ›ii de cost n pentru TSP fiind echivalentÄƒ cu existenÈ›a unui ciclu hamiltonian Ã®n graf. Cum problema determinÄƒrii unui ciclu hamiltonian este NP-completÄƒ nu existÄƒ algoritm polinomial care sÄƒ o poatÄƒ rezolva, deci se ajunge la o contradicÈ›ie. Presupunerea fiind falsÄƒ, se concluzioneazÄƒ cÄƒ TSP este NP-completÄƒ."              
            }
            , "conclusion": "\t Ãncadrarea problemei comis-voiajorului Ã®n clasa NP-completÄƒ Ã®nseamnÄƒ cÄƒ nu se cunoaÈ™te un algoritm care sÄƒ ofere o soluÈ›ie Ã®n timp polinomial È™i gÄƒsirea unui astfel de algoritm este cel mai probabil imposibilÄƒ (nu se È™tie exact deoarece nu s-a putut demonstra ğ‘ƒ = ğ‘ğ‘ƒ, dar nici nu se exclude cu certitudine aceastÄƒ afirmaÈ›ie)."
        }
    },
    "variations": {
       "asymmetric": {
            "title": "TSP asimetric - aTSP",
            "header": "\t Ãn oglindÄƒ cu sTSP, existÄƒ problema comis-voiajorului asimetricÄƒ (prescurtat aTSP). Acum sunt douÄƒ direcÈ›ii de mers, drumul de la i la j È™i cel de la j la i poate sÄƒ difere ca lungime. Cu alte cuvinte, "
            ,"explication": "graful asociat este orientat, deci matricea D nu este neapÄƒrat simetricÄƒ."
            , "comutation-atsp-stsp": {
                "title": "\t Fun fact!"
                , "text": "\t aTSP conÈ›ine sTSP ca È™i caz special pentru cÄƒ o muchie (i,j) din sTSP este vÄƒzutÄƒ ca douÄƒ muchii (i,j) È™i (j,i) Ã®n aTSP. Interesant este cÄƒ È™i aTSP-ul poate fi transformat Ã®n varianta generalÄƒ, caz discutat mai jos."
            }
           , "subtitle-transformation": "Transformare din aTSP Ã®n sTSP"
            , "transformation": {
                "text": "\t Un TSP asimetric cu n oraÈ™e se poate transforma Ã®ntr-un TSP simetric cu 2n oraÈ™e. Fie D matricea corespunzÄƒtoare unui sTSP. Acest fapt este important dacÄƒ se doreÈ™te rezolvarea unui aTSP folosind un algoritm proiectat doar pentru sTSP."
                , "step-0": " PaÈ™i de rezolvare:"
                , "step-1": "Se creeazÄƒ matricea D' care este identicÄƒ cu matricea D excepÈ›ie fÄƒcÃ¢nd pe poziÈ›iile d'(i,i) care au valoarea -M Ã®n loc de 0, È™tiind cÄƒ M este un numÄƒr foarte mare"
                , "step-2": "Se creeazÄƒ matricea U unde u(i,j) = âˆ pentru orice i, j âˆˆ {1,â€¦,n}."
                , "step-3": "sTSP-ului cu matricea D Ã®i corespunde un aTSP cu matricea D'' de dimensiune (2n x 2n) definitÄƒ astfel:"
                , "step-4": " Valoarea TSP pentru matricea D este valoarea TSP a matricei  D'' create la care se adÄƒuga de n ori valoarea -M (graful corespunzÄƒtor matricei D'' conÈ›ine n muchii cu costul -M, muchii ce nu existÄƒ Ã®n graful corespunzÄƒtor lui D):"
            } 
            , "solution-formula": "aTSP = sTSP + n * M"
            , "subtitle-exemplu": "Exemplu pe o matrice datÄƒ"
            , "slider": {
                "0": "Transformare din aTSP in sTSP. Graful nou va avea 2n noduri (Ã®n loc de n)"
                , "1": "Muchia de la nodul i la nodul (i + n) are valoarea -999 (orice valoare micÄƒ astfel Ã®ncÃ¢t sa asigure alegerea acelei muchii cÃ¢nd se ajunge Ã®n i). DacÄƒ Ã®n graful iniÈ›ial d(0, 2) = 4, acum d(0, 4) = -999 È™i d(4, 2) = 4"
                , "2": "Astfel dintr-un nod i dintr-un graf orientat s-au creat 2 noduri i È™i (i + n) Ã®n graful neorientat: se intrÄƒ Ã®n nodurile cu indice < n È™i se iese din cele cu indice >= n"
                , "3": "SoluÈ›ia aTSP-ului iniÈ›ial este aceeaÈ™i cu a sTSP-ului rezultat excepÈ›ie cÄƒ la aceasta din urmÄƒ a fost adÄƒugat de n ori valoarea -999 (M = 999). Deci aTSP = sTSP + n * M"
            }
   
        }, 
        "multipleVisits": {
            "title":  "TSP cu vizitÄƒri multiple",
            "header": "\t PlecÃ¢nd de la sTSP, TSP cu vizitÄƒri multiple permite vizitarea aceluiaÈ™i nod de mai multe ori Ã®n cazul Ã®n care acest fapt duce la determinarea unei soluÈ›ii mai eficiente decÃ¢t soluÈ›ia oferitÄƒ de sTSP."
            , "slider": {
                "0": "SoluÈ›ia sTSP este 8 datÄƒ de ciclul 0 â†’ 1 â†’ 2 â†’ 3 â†’ 0"
                , "1": "Se observÄƒ cÄƒ soluÈ›ia ar fi minimÄƒ dacÄƒ se permite trecerea de douÄƒ ori prin nodul 0: 0 â†’ 1 â†’ 2 â†’ 0 â†’ 3 â†’ 0. Ciclul are valoarea 6"
            }
        },
        "max": {
            "title": "Max TSP",
            "header": "\t Max TSP de diferenÈ›iazÄƒ de TSP-ul general prin faptul ca are ca scop gÄƒsirea drumului de lungime maximÄƒ din graful G."  
            , "steps" : { 
                "0": "PaÈ™i algoritm",
                "1": "Se Ã®nlocuiesc ponderele cu inversele lor", 
                "2": "Se adunÄƒ fiecare ponderÄƒ cu o constantÄƒ c astfel Ã®ncÃ¢t toate muchiile sÄƒ devinÄƒ pozitive (TSP nu acceptÄƒ muchii negative)",
                "3": "Se aplicÄƒ algoritmul pentru TSP pe graful creat",
                "4": "SoluÈ›ia problemei este urmÄƒtoarea:"
                ,"formula": "MaxTSP = - (TSP - c*n)"
            }
            , "slider": {
                "0": "Se pleacÄƒ de la graful complet È™i simetric"
                , "1": "Se Ã®nlocuiesc ponderile cu inversele lor È™i apoi se alege c Ã®ndeajuns de mare ca toate ponderile sÄƒ devinÄƒ pozitive. Iau c = 10"
                , "2": "Se cautÄƒ ciclul hamiltonian de cost minim"
                , "3": "SoluÈ›ia TSP este 27, deci soluÈ›ia MaxTSP este 13"
            }
        },
        "metric": {
            "title": "Metric TSP",
            "header": "\t Problema comis-voiajorului Ã®n cazul metric pleacÄƒ de la TSP-ul uzual pentru care matricea este simetricÄƒ, ponderile sunt nenegative È™i distanÈ›a de la un nod la el Ã®nsuÈ™i este 0 â€“ la acestea adÄƒugÃ¢ndu-se necesitatea satisfacerii inegalitÄƒÈ›ii triunghiului:"
            , "formula": "d(i,j) â‰¤ d(i,k) + d(k,j) âˆ€ i,j,k âˆˆ V, iâ‰ j, iâ‰ k, jâ‰ k \n Pentru a se putea respecta inegalitatea triunghiului graful trebuie sÄƒ fie complet, adicÄƒ sÄƒ existe muchie Ã®ntre oricare douÄƒ noduri."
            , "connectin-with-christofides": {
                "text": "\t TSP metric este o variaÈ›ie importantÄƒ Ã®ntrucÃ¢t se Ã®ntÃ¢lneÈ™te des Ã®n practicÄƒ È™i spre deosebire de cazul general existÄƒ algoritmi de aproximare cu factor constant care sÄƒ rezolve problema, cel mai cunoscut fiind algoritmul lui Christofides care va fi discutat Ã®n "
                , "linkText": " SecÈ›iunea Algoritmi de aproximare"
            }
            , "euclidian-tsp": {
                "title": "TSP euclidian"
                , "text": "\t Un caz special de TSP metric este TSP Ã®n forma euclidianÄƒ Ã®n care distanÈ›a dintre douÄƒ oraÈ™e este distanÈ›a euclidianÄƒ corespunzÄƒtoare punctelor Ã®n plan. De exemplu, Ã®n cazul Ã®n care numÄƒrul dimensiunilor Ã®n spaÈ›iul euclidian este doi (echivalent cu faptul cÄƒ pentru orice punct existÄƒ coordonatele x È™i y), formula de a afla distanÈ›a dintre oraÈ™ele X(a, b) È™i Y(c, d) este: "
                , "formula": "d(X, Y) = d(Y, X) = âˆš((a - c)^2 + (b - d)^2)"
            }
            , "slider": {
                "0": "Verificare dacÄƒ graful aparÈ›ine unui TSP metric"
                , "1": "Se observÄƒ cÄƒ graful nu aparÈ›ine unui TSP metric, nerespectÃ¢ndu-se inegalitatea triunghiului: d(1, 3) > d(1, 0) + d(0, 3)"
            } 
        }
    },
    "exact-algorithms": {
         "header": "\t Algoritmii exacÈ›i sunt algoritmi care, dupÄƒ cum le zice numele, oferÄƒ soluÈ›ii cu certitudine optime. Ãn mod general, aceÈ™tia ruleazÄƒ Ã®n timp exponenÈ›ial, dar se poate ajunge la timp polinomial pentru anumite instanÈ›e speciale."
        , "dynamic-programming": {
            "title": "Programare dinamicÄƒ"
            , "text": "\t Programarea dinamicÄƒ este una din cÄƒile mai rapide de a rezolva TSP comparative cu backtracking care se realizeazÄƒ Ã®n timp factorial. Algoritmul care foloseÈ™te programare dinamicÄƒ pentru TSP se numeÈ™te Bellman-Help-Karp È™i funcÈ›ioneazÄƒ pentru un n care poate ajunge pÃ¢nÄƒ la 30. NumÄƒrul de oraÈ™e este Ã®ncÄƒ mic, dar fiind o problemÄƒ NP, este dificil de realizat un algoritm pÃ¢nÄƒ È™i pentru numere relativ mici."
            , "definition": "\t Programarea dinamicÄƒ presupune rezolvarea problemei folosind subprograme ce returneazÄƒ soluÈ›ii parÈ›iale care sunt folosite Ã®n mod recursiv cu scopul de a ajunge la soluÈ›ia Ã®ntregei probleme. Cu alte cuvinte, o problemÄƒ mai mare A este rezolvatÄƒ folosind rezultatul unei probleme mai mici B (numitÄƒ subproblemÄƒ), deci problema B trebuie sÄƒ fie È™tiutÄƒ Ã®nainte de a rezolvÄƒ problema A - de aici ideea de recursivitate, mergÃ¢ndu-se de la mic la mare. Pentru a nu rezolva o problemÄƒ mai micÄƒ de mai multe ori, se memoreazÄƒ rezultatele parÈ›iale È™i se reutilizeazÄƒ."
            ,"analogy-to-tsp": {
                "subproblem": {
                    "title": "Cum se stabileÈ™te subproblema?"
                    , "text": "\t Pentru TSP o subproblemÄƒ corespunde pÄƒrÈ›ii de Ã®nceput a drumului. Se considerÄƒ cÄƒ se porneÈ™te parcurgerea din oraÈ™ul 1 È™i se ajunge Ã®n oraÈ™ul j dupÄƒ ce au fost vizitate cÃ¢teva oraÈ™e. La fiecare pas, pentru a extinde Ã®nceputul de drum, este necesar sÄƒ se cunoascÄƒ oraÈ™ul j pentru cÄƒ se doreÈ™te gÄƒsirea oraÈ™elor de vizitat dupÄƒ ce s-a trecut prin j. Pentru a È™ti cÄƒ se respectÄƒ regula TSP de a vizita fiecare oraÈ™ o singurÄƒ datÄƒ, trebuie sÄƒ se cunoascÄƒ È™i identitatea nodurilor vizitate Ã®n drumul parÈ›ial pentru a nu le parcurge din nou, de aceea:"
                    , "formula": "o subproblemÄƒ corespunde unei perechi de forma (submulÈ›ime de noduri, ultimul nod din drum)"
                    
                } 
                , "final-step": {
                    "title": "Ultimul pas"
                    , "text": "\t SoluÈ›ia optimÄƒ reprezintÄƒ Ã®ntregirea ciclului prin aducerea nodului j Ã®napoi la nodul de start 1. La acest pas se È™tiu toate drumurile din 1 È™i ajuns Ã®n j âˆˆ {2,â€¦,n}, deci existÄƒ n-1 candidaÈ›i la soluÈ›ia optimÄƒ a problemei. SoluÈ›ia este stabilitÄƒ prin obÈ›inerea sumei minime dintre fiecare drum care se opreÈ™te Ã®n j È™i ponderea muchiei (j,1)."
                    , "formula": "soluÈ›ia optimÄƒ = min ( (drumul cel mai scurt de la 1 la j conÈ›inÃ¢nd toate nodurile din V) + d(j,1) )"
                }
                , "intermediar-step": {
                    "title": "Pas intermediar - RelaÈ›iile de recurentÄƒ"
                    , "text":  "\t Un drum optim P care porneÈ™te din 1 È™i se terminÄƒ Ã®n j È™i trece prin nodurile din mulÈ›imea S se obÈ›ine dintr-un drum optim P'âŠ† P, P' = P - {j} care Ã®ncepe Ã®n 1 È™i se terminÄƒ Ã®n i È™i trece prin nodurile din S - {j} adÄƒugÃ¢nd muchia (i, j)."
                }
            } 
            , "recursion": {
                "title": "Recursivitate"
                , "header": "\t Pentru o submulÈ›ime S âŠ† {1,â€¦,n} care conÈ›ine 1 È™i j, fie subproblema M(S,j) = lungimea celui mai scurt drum P de la nodul 1 la j vizitÃ¢nd nodurile din S o singurÄƒ datÄƒ."
                , "steps": "Recursivitatea prezintÄƒ douÄƒ pÄƒrÈ›i: "
                , "first-step": {
                    "step": "cazul de oprire"
                    , "text": "se referÄƒ la subproblemele care se pot rezolva direct. AvÃ¢nd Ã®n vedere cÄƒ se lucreazÄƒ cu mulÈ›imi, ne oprim cÃ¢nd Ã®n P nu mai existÄƒ un nod i intermediar astfel Ã®ncÃ¢t sÄƒ se formeze drumul Pâ€™. AÈ™adar dacÄƒ submulÈ›ime S corespunzÄƒtoare drumului P este de forma {1,j}, valorile lui M sunt ponderile muchiilor din matricea de distanÈ›e D:"
                    , "formula": "M(S,j) = d(1,j)"
                }
                , "middle-step": {
                    "step": "relaÈ›ia recursivÄƒ"
                    , "text": "la orice pas intermediar M(S,j), problema se rezumÄƒ la stabilirea penultimul nod iâˆˆS astfel Ã®ncÃ¢t drumul de la 1 la i notat cu  M(S-{j},i) plus lungimea ultimei muchii d(i, j) este minim:"
                    , "formula": "M(S,j) = min (iâˆˆS; iâ‰ 1,j) (M(S-{j},i)  + d(i,j))"
                }
                , "final-step": {
                    "text1": "\t Legat de "
                    , "step": "ultimul pas "
                    , "text2": "se È™tie nodul unde se doreÈ™te sÄƒ se ajungÄƒ È™i toate cele n-1 posibilitÄƒÈ›i de drumuri:"
                    , "formula": "M(V,1) = min (j âˆˆ V-{1}) (M(V,j) + d(j,1))"
                }
            }
            , "complexity": {
                "theorem": "\t Algoritmul Bellman-Help-Karp are timpul de rulare O(n^2 * 2^n). \nDemonstraÈ›ie: Chiar dacÄƒ se È›ine evidenÈ›a tuturor submulÈ›imilor S, nu conteazÄƒ ordinea vizitÄƒrii nodurilor din S Ã®ntrucÃ¢t doar identificarea acestora este importantÄƒ pentru a nu parcurge un nod de mai multe ori. Acest aspect face diferenÈ›a timpului de rulare dintre varianta cu programare dinamicÄƒ È™i cea cu forÈ›Äƒ brutÄƒ: Ã®n cazul Ã®n care conta ordinea dintre nodul sursÄƒ È™i nodul destinaÈ›ie se ajungea la n! subprograme pe cÃ¢nd acum sunt 2^n posibilitÄƒÈ›i de a alege S. Sunt n posibilitÄƒÈ›i pentru destinaÈ›ia j, nodul care se Ã®ntoarce Ã®n 1, È™i n variante de a alege nodul i (penultimul din drum), iâˆˆS. AÈ™adar, timpul de rulare rezultat este O(n^2 * 2^n)."   
            }
            , "pseudocode": {
                "pseudocode": "D â† matrice n x n de distanÈ›e Ã®ntre oricare 2 oraÈ™e  \n M â† matrice 2^n x n iniÈ›ializatÄƒ cu âˆ \n pentru j â† 2, n executÄƒ \n \t M({1, j}, j) â† d(1,j) \n pentru s â† 3, n executÄƒ \n \t pentru toate submulÈ›imile S âŠ† {1,â€¦,n} cu 1 âˆˆ S È™i |S| = s executÄƒ \n \t\t pentru orice j âˆˆ S, j â‰  1 executÄƒ \n \t\t\t M(S,j) â† min (M(S-{j},i) + d(i,j)) pentru iâˆˆS; iâ‰ 1,j \n return min (M({1,â€¦,n},j) + d(j,1))"
                , "explications": {
                    "text": "\t Ãn implementarea algoritmului, submulÈ›imile S se pot stoca prin scriere Ã®n binar a nodurilor ce le compun astfel: bitul egal cu 1 Ã®nseamnÄƒ cÄƒ nodul de pe poziÈ›ia respectivÄƒ existÄƒ Ã®n submulÈ›ime È™i 0 cÄƒ nu existÄƒ. De exemplu, submulÈ›imii {0,1,2} Ã®i corespunde Ã®n binar 0111 care reprezintÄƒ numÄƒrul 7. Prin urmare, Ã®n matricea M S este plasat pe linia 7 a matricei. Verificarea dacÄƒ nodul j este inclus Ã®n submulÈ›imea S se realizeazÄƒ prin operaÈ›ia de Ã®nmulÈ›ire bit cu bit (&) Ã®ntre cele douÄƒ mulÈ›imi (S È™i mulÈ›imea ce Ã®l conÈ›ine doar pe j determinatÄƒ prin È™iftarea la stÃ¢nga a lui j: 1 << j). Pentru j = 2, aceasta Ã®nseamnÄƒ: 7 & (1 << 2) = 0111 & 0100 = 0100. Rezultatul este diferit de 0, aÈ™adar j aparÈ›ine mulÈ›imii. \n\t Pentru a determina drumul S'= S-{j} se face XOR Ã®ntre S È™i {j}: S ^ (1 << j) = 0111 ^ 0100 = 0011. RezultÄƒ cÄƒ S' este 3."
                }
            }
        }
        , "branch-and-bound": {
            "title": "Branch and bound"
            , "text": "\t Metoda Branch and Bound se aplicÄƒ problemelor care pot fi rezolvate prin backtracking, deci reprezentate printr-un arbore. Comparativ cu backtrackingul, arborele metodei branch and bound este construit dinamic fiind eliminaÈ›i subarborii care depÄƒÈ™esc o limitÄƒ superioarÄƒ a soluÈ›iei optime. AceastÄƒ limitÄƒ poate fi lungimea primului ciclu gÄƒsit care, este sigur mai mare sau egalÄƒ cu soluÈ›ia optimÄƒ. Deci, Ã®n cazul Ã®n care o soluÈ›ie parÈ›ialÄƒ ar depÄƒÈ™i-o, nu are rost sÄƒ se continue drumul respectiv. Astfel nu se parcurge tot arborele, micÈ™orÃ¢nd complexitatea problemei, iar scopul este gÄƒsirea acelui vÃ¢rf rezultat (frunzÄƒ) care oferÄƒ soluÈ›ia optimÄƒ din totalul de vÃ¢rfuri rezultat. \n\t Nodurile arborelui corespund stÄƒrilor posibile Ã®n dezvoltarea soluÈ›iei, stÄƒri ce corespund traseului de la rÄƒdÄƒcinÄƒ pÃ¢nÄƒ la nodul respectiv. Ideea aceasta este Ã®ntÃ¢lnitÄƒ È™i la arborele metodei backtracking."
            , "lim": {
                "title": "Alegerea limitei superioare"
                , "name": "lim"
                , "0": "iniÈ›ial, neÈ™tiind dacÄƒ instanÈ›a are soluÈ›ie, este iniÈ›ializat cu âˆ sau cu o limitÄƒ teoreticÄƒ cunoscutÄƒ"
                , "1": "reprezintÄƒ o aproximaÈ›ie prin adaos a minimului cÄƒutat fiind folositoare pentru a elimina din L nodurile cu cost mai mare decÃ¢t ea, adicÄƒ nodurile care prin a cÄƒror extindere nu se obÈ›ine soluÈ›ia optimÄƒ. Prin eliminarea unui nod, se elimina tot subarborele pentru care nodul respectiv este rÄƒdÄƒcinÄƒ."
                , "2": "se actualizeazÄƒ pe parcursul algoritmului, luÃ¢nd valoarea oricÄƒrui ciclu  cu valoare mai micÄƒ decÃ¢t a sa"
                , "3": "la final reprezintÄƒ valoarea soluÈ›iei optime"
            }
            , "pseudocode": { 
                "text": "\t  Fie f(i) limita inferioarÄƒ pentru ciclul minim corespunzÄƒtor nodului i, nod_start rÄƒdÄƒcina, nodul de Ã®nceput, È™i drum_optim variabila Ã®n care se reÈ›ine drumul de la rÄƒdÄƒcinÄƒ pÃ¢nÄƒ la frunzÄƒ corespunzÄƒtor soluÈ›iei minime gÄƒsite. \n\t AvÃ¢nd Ã®n vedere ca parcurgerea merge din nodul curent Ã®n fiu, apoi Ã®n fiul fiului È™i aÈ™a mai departe, se propune rezolvarea problemei folosind o metoda recursivÄƒ È™i o altÄƒ metodÄƒ Ã®n care se iniÈ›ializeazÄƒ valorile È™i se apeleze funcÈ›ia recursivÄƒ."
                , "pseudocode-recursion": "Pseudocod parcurgere(i, drum) \n distanÈ›a_minimÄƒ â† âˆ \n nod_urmÄƒtor â† -1 \n dacÄƒ f(i) < lim atunci \n\t dacÄƒ lista drum conÈ›ine toate nodurile atunci \n\t\t lim â† f(i) \n\t\t drum_optim â† drum \n\t altfel \n\t\t cÃ¢t timp i mai are fii j executÄƒ \n\t\t\t nod_urmÄƒtor â† nodul j cu f(j) minim \n\t\t\t drum_urmÄƒtor â† drum la care se adaugÄƒ nod_urmÄƒtor \n\t\t\t parcurgere(nod_urmÄƒtor, drum)"
                , "pseudocode-branch-and-bound": "Pseudocod Branch_and_bound \n seteazÄƒ nodul de start \n lim â† âˆ \n drum_optim â† lista vidÄƒ \n parcurgere(nod_start) \n dacÄƒ lim = âˆ atunci \n\t scrie 'Nu existÄƒ soluÈ›ie'\n altfel \n returneazÄƒ lim, drum_optim"
                , "explications": {
                    "text": "\t Codul include optimizarÄƒri la nivel de cod pentru a oferi un timp mai scurt de rulare, precum: folosirea unui cozi de prioritÄƒÈ›i folosind heapq Ã®n loc de queue. PriorityQueue pentru a reÈ›ine limitele interioare f Ã®ntrucÃ¢t cea dintÃ¢i este mai lentÄƒ atunci cÃ¢nd are de-a face cu un numÄƒr mare de date. Ãn adaos, distanÈ›ele dintre oraÈ™e sunt reÈ›inute Ã®ntr-o matrice din clasa numpy pentru a eficientiza operaÈ›iile pe matrice (cÄƒutarea minimului, scÄƒderea pe linie/coloana a acestuia, copierea). Rapiditate este oferitÄƒ È™i de folosirea funcÈ›iei copy din numpy Ã®n loc de deepcopy din copy."
                }
            }
            , "strategy": {
                "title": "Strategie folositÄƒ pentru a ajunge la o frunzÄƒ"
                , "steps": {
                    "0": "pentru nodul curent se genereazÄƒ toÈ›i fiii È™i li se calculeze costul"
                    , "1": "nodul ales ca nod urmÄƒtor este cel cu costul minim (asemÄƒnarea cu BFS)"
                    , "2": "la urmÄƒtorul pas din nou se genereazÄƒ toÈ›ii fii, iar alegerea noului nod se face din fii direcÈ›i ai nodului curent"
                    , "3": "se repetÄƒ pÃ¢nÄƒ se ajunge la o frunzÄƒ"
                    , "4": "cÃ¢nd se ajunge la o frunzÄƒ j care are ca tatÄƒ pe i, se face un pas Ã®n spate Ã®n i È™i se alege ca nod curent fiul nevizitat al lui i cu costul minim. Se repetÄƒ algoritmul de la primul pas"
                }
                , "text": "\t Strategia prezentatÄƒ genereazÄƒ n * (n - 1) / 2 fii pentru a ajunge la o frunzÄƒ."
                , "benefits" : {
                    "text": "Avantaje ale acestei strategii Ã®n cazul problemelor Ã®ntÃ¢lnite pentru TSP euclidian (unde graful este complet): "
                    , "0": "face mai puÈ›ini paÈ™i (generÄƒri de fii) decÃ¢t ar face BFS"
                    , "1": "oferÄƒ o limitÄƒ superioarÄƒ mai bunÄƒ ca Ã®n cazul Ã®n care s-ar folosi DFS"
                }
            }
            , "construction": {
                "text": "\tPartea nediscutatÄƒ este legatÄƒ de calculul funcÈ›iei f(i) astfel Ã®ncÃ¢t sÄƒ reprezinte limita inferioarÄƒ a unui ciclu. ExistÄƒ mai multe modalitÄƒÈ›i de a defini funcÈ›ia, cea mai cunoscutÄƒ bazÃ¢ndu-se pe reducerea matricei de distanÈ›e astfel pornind de la urmÄƒtoarea observaÈ›ie. DacÄƒ se micÈ™oreazÄƒ toate elementele de pe o linie i sau coloanÄƒ j din D cu o valoare Î±, orice ciclu hamiltonian va avea costul micÈ™orat cu Î± pentru cÄƒ se intrÄƒ o singurÄƒ datÄƒ Ã®n nodul j È™i se pleacÄƒ o singurÄƒ datÄƒ din nodul i. Se menÈ›ioneazÄƒ ca distanÈ›a de la un nod la el Ã®nsuÈ™i nu mai este 0, ci infinit pentru a putea exista un Î± diferit de 0. \n\t AÈ™adar apare noÈ›iunea de matrice de distanÈ›e redusÄƒ, matricea obÈ›inutÄƒ prin micÈ™orÄƒri repetate pÃ¢nÄƒ cÃ¢nd pe orice linie È™i coloanÄƒ apare cel puÈ›in un 0, excepÈ›ie fÄƒcÃ¢nd cazul Ã®n care linia/coloana conÈ›ine numai âˆ. \n\t Revenind la limita inferioarÄƒ f, f(nod_start) reprezintÄƒ valoarea cu care se reduce matricea iniÈ›ialÄƒ D. Unui nod oarecare j Ã®i este asociatÄƒ matricea de distanÈ›e redusÄƒ anterior de pÄƒrintele sÄƒu. PresupunÃ¢nd cÄƒ j Ã®l are ca tatÄƒ pe i, se reduce Dj astfel:"
                , "steps": {
                    "0": "Elementelei liniei i devin âˆ (numai o singurÄƒ datÄƒ se iese din i)"
                    , "1": "Elementele coloanei j devin âˆ (numai o singurÄƒ datÄƒ se intrÄƒ Ã®n j)"
                    , "2": "Dj(j,nod_start) = âˆ pentru a Ã®mpiedica Ã®nchiderea circuitului Ã®nainte de a parcurge toate nodurile"
                    , "3": "Fie Î± cantitatea cu care s-a redus matricea Dj, atunci:"
                    , "3-formula": "f(j) = f(i) + Di(i,j) + Î±"
                }
                , "example-on-a-given-matrix": "Exemplu reducere pe o matrice D datÄƒ"
                , "solution": {
                     "text": "\t SoluÈ›ia problemei este:"
                    , "formula": " min {f(i) unde i este frunzÄƒ}"
               } 
            }
            , "complexity": {
                "text": "\t La bazÄƒ, metoda este asemÄƒnÄƒtoare cu varianta care foloseÈ™te backtracking, prin urmare, Ã®n worse case, ajunge sÄƒ parcurgÄƒ toÈ›i subarborii, deci sÄƒ necesite timp exponenÈ›ial. ÃnsÄƒ, Ã®n caz favorabil, timpul de rulare este diminuat de reducerea repetatÄƒ a matricei de distanÈ›Äƒ, aceasta ajutÃ¢nd la prezicerea drumului optim, È™i de eliminare a subarborilor care Ã®ntrec aproximaÈ›ia soluÈ›iei optime."
            }
            , "image-text": {
                "image-1-text-1": "Arbore asociat grafului prezentat Ã®n"
                ,"image-1-text-2": "subsecÈ›iunea TSP asimentric"
                , "image-2-text-1": "Arbore rezultat asociat grafului dupa ce s-a aplicat strategia propusÄƒ"
            }
        }
    }
    , "approximations-algorithms": {
        "header": "\t Algoritmi aproximativi sunt acei algoritmi pentru care se doreÈ™te returnarea unui rezultat, pentru orice instanÈ›Äƒ, Ã®ntr-un anumit relativ timp scurt. AceÈ™tia se numesc algoritmi aproximativi, necesitatea gÄƒsirii soluÈ›iei optime fiind relaxatÄƒ, fiind acceptabile soluÈ›ii â€destul de buneâ€, apropiate de cea optimÄƒ, cu un factor de aproximare garantat. "
        , "definition-alpha-factor": "\t Pentru o problemÄƒ de optimizare, un algoritm ğ›¼-aproximativ este un algoritm polinomial care pentru toate instanÈ›ele problemei produc o soluÈ›ie ALG a cÄƒrei valoare este Ã®ntr-un factor de ğ›¼ faÈ›Äƒ de valoarea soluÈ›iei optime OPT (ALG â‰¤ ğ›¼ OPT pentru o problemÄƒ de minimizare È™i ALG â‰¥ ğ›¼ OPT pentru o problemÄƒ de maximizare). Pentru un algoritm ğ›¼-aproximativ, ğ›¼ reprezintÄƒ factorul de aproximare al algoritmului."
        ,"approximation-factor": {

        }
        , "double-tree-algorithm": {
            "title": "Algoritmul arborelui dublat (Double tree algorithm)"
            , "header": "\t Algoritmul arborelui dublat este un algoritm aproximativ care rezolvÄƒ TSP metric a cÄƒrui nume provine din faptul cÄƒ pentru rezolvarea problemei sunt dublate muchiile arborelui de cost minim pentru a se putea crea un ciclu eulerian È™i mai apoi ciclul hamiltonian. "
            , "eulerian": {
                "0": "Ciclul È™i graful eulerian:"
                ,"1": "Un ciclu eulerian presupune parcurgerea tuturor muchiilor o singurÄƒ datÄƒ fiind permisÄƒ repetarea nodurilor."
                ,"2": "Un graf se numeÈ™te eulerian dacÄƒ are un ciclu eulerian."
                ,"3": "Un graf neorientat fÄƒrÄƒ noduri izolate are un ciclu eulerian dacÄƒ È™i numai dacÄƒ este conex È™i are toate nodurile de grad par."
                
            }, "theorem-subset-hamiltonian-cycle": "\t Fie submulÈ›imea ğ‘† âŠ† ğ‘‰. Un ciclul hamiltonian de cost minim ğ¶ğ‘† din subgraful indus de nodurile lui ğ‘† respectÄƒ proprietatea ğ‘™(ğ¶ğ‘†) â‰¤ ğ‘‚ğ‘ƒğ‘‡. \nDemonstraÈ›ie: Fie ğ‘† = ğ‘‰â€“{ğ‘˜}. Un ciclu hamiltonian Ã®n graful indus de S se poate obÈ›ine dintr-un ciclu hamiltonian al lui G prin scurtcircuitate aÈ™a cum este vizibil Ã®n Figura 3.1. RespectÃ¢ndu-se inegalitatea triunghiului, muchia (i,j) este cel mult egalÄƒ cu suma celor douÄƒ muchii care nu fac parte din ciclu scurtcircuit. De aici rezultÄƒ cÄƒ ğ‘™(ğ¶ğ‘†) â‰¤ğ‘‚ğ‘ƒğ‘‡."
            , "steps": {
                "header": "PaÈ™i algoritm"
                , "prim": "Primul pas al rezolvÄƒrii problemei TSP este determinarea arborelui de acoperire de cost minim (MST, minimum-cost spanning tree) T. Acesta poate fi aflat, de exemplu, cu algoritmul lui Prim sau Kruskal."
                , "prim-approximation-theorem": "\t Valoarea arborelui de acoperire de cost minim este cel mult valoarea ciclului TSP, adicÄƒ l(T) â‰¤ OPT. \n DemonstraÈ›ie: DacÄƒ din ciclul hamiltonian OPT se eliminÄƒ o muchie se obÈ›ine un arbore parÈ›ial care are costul mai mare sau egal cu l(T)."
                , "dfs": {
                    "text": "Pentru a parcurge toate muchiile din arborele de acoperire dublat Ã®n cÄƒutarea unui ciclu eulerian, se propune urmÄƒtoarea strategie cunoscutÄƒ sub numele de parcurgerea Ã®n adÃ¢ncime (DFS, depth-first search): "
                    , "1": "Se ia un nod i din arbore"
                    , "2": {
                        "1": "DacÄƒ existÄƒ o muchie de forma (i,j) nevizitatÄƒ, se merge pe acea muchie, iar i := j. Se repetÄƒ pasul 2."
                        , "2": "DacÄƒ toate muchiile care pornesc din i sunt vizitate, se doreÈ™te sÄƒ se facÄƒ un pas Ã®n spate. DacÄƒ i este nodul ales pasul 1, i nu are unde sÄƒ se Ã®ntoarcÄƒ, deci stop; altfel i := k unde k este nodul Ã®n care se Ã®ntoarce È™i se repetÄƒ pasul 2."
                    }   
                }
                , "shortcuts": "Se foloseÈ™te tehnica scurtÄƒturilor (shortcutting) prin care din parcurgerea determinatÄƒ anterior (Ã®n care muchiile se repetÄƒ de douÄƒ ori), se pÄƒstreazÄƒ doar prima apariÈ›ie a fiecÄƒrui nod, adicÄƒ se sare peste nodurile deja vizitate"
                , "approximation": "\t Algoritmul arborelui dublat pentru problema comis voiajorului Ã®n cazul metric este 2-aproximativ. \nDemonstraÈ›ie: NotÄƒm cu OPT soluÈ›ia grafului G pentru problema TSP. AvÃ¢nd Ã®n vedere cÄƒ se respectÄƒ inegalitatea triunghiului, muchiile obÈ›inute prin folosirea scurtÄƒturilor sunt sigur mai mici sau egale cu cele peste care s-a sÄƒrit. AÈ™adar nu se va mÄƒri niciodatÄƒ distanÈ›a totalÄƒ a turului. Fiind T' arborele obÈ›inut Ã®n urma tehnicii de shortcut-uri, avem cÄƒ l(T') â‰¤ 2 l(T) â‰¤ 2 OPT. Pentru cÄƒ l(T') â‰¤ 2 OPT, acest algoritm este 2-aproximativ"
            }
            , "algorithm": {
                "prim": {
                    "title": "Prim"
                    , "0": "se È›ine evidenÈ›a nodurilor ce fac parte din arbore pentru a nu adÄƒuga de douÄƒ ori acelaÈ™i nod Ã®n arbore Ã®ntr-un vector numit vizitat"
                    , "1": "se È›ine evidenÈ›a distanÈ›ei minime de la fiecare nod nevizitat (care nu face parte din arbore) la arbore (nodurile care deja fac parte din arbore) Ã®ntr-un vector numit distanÈ›a."
                    , "2": "se foloseÈ™te o coadÄƒ de prioritÄƒÈ›i pentru stocarea datelor sub formÄƒ de triplete [distanÈ›Äƒ minimÄƒ, nod, tata]: pentru fiecare nod nevizitat (vizitat[nod] == 0) se Ã®ntroduce un triplet Ã®n coadÄƒ dacÄƒ d[nod] se actualizeazÄƒ"
                    , "3": "la fiecare pas se scoate din coadÄƒ nodul cu distanÈ›a minimÄƒ se reÈ›ine muchia Ã®ntr-o listÄƒ de adiacentÄƒ È™i se recalculeazÄƒ distanÈ›ele de la noul nou Ã®ntrodus Ã®n arbore la nodurile nevizitate cu scopul de a gÄƒsi distanÈ›e mai mici"
                    , "pseudocode": "distanÈ›a â† vector de lungime n iniÈ›ializat cu âˆ \n arbore â† listÄƒ de n liste ce reprezintÄƒ lista de adiacenÈ›Äƒ \n vizitat â† vector de lungime n iniÈ›ializat cu 0 \n distanÈ›a[nod_start]  â† 0 \n h â† [[0, nod_start, -1]]     // rÄƒdÄƒcina nu are ascendent \n pentru paÈ™i â† 1, n executÄƒ \n\t nod, tata  â† nodul nevizitat cu distanÈ›a mininÄƒ din h, respectiv tatÄƒl acestui nod \n\t adaugÄƒ la lista arbore[nod] nodul tata \n\t adaugÄƒ la lista arbore[tata] nodul nod \n\t vizitat[nod] â† 1 \n\t pentru vecin â† 0, n - 1 executÄƒ \n\t\t dacÄƒ d(nod, vecin) â‰  âˆ È™i vizitat[vecin] = 0 È™i distanÈ›a[vecin] > d(nod, vecin) atunci \n\t\t\t distanÈ›a[vecin] â† d(nod, vecin) \n\t\t\t adaugÄƒ la h tripletul [distanÈ›a(vecin), vecin, nod] \n returneazÄƒ arbore"
                }
                , "dfs": {
                    "title": "DFS care nu reÈ›ine nodurile deja vizitate pentru a sÄƒri peste pasul cu shortcutting"
                    , "pseudocode": "Pseudocod Ciclu_hamiltonian(arbore) \n se alege random un nod de start È™i se noteazÄƒ cu k \n vizitat â† vector de lungime n iniÈ›ializat cu 0 \n ciclu â† listÄƒ iniÈ›ial vidÄƒ Ã®n care se va reÈ›ine ciclul hamiltonian \n Parcurgere(k, arbore) \n adaugÄƒ la ciclu nodul k      // muchia de Ã®ntoarcere \n\n Pseudocod Parcurgere(i, arbore) \n vizitat[i] â† 1 \n adaugÄƒ pe i la ciclu \n pentru fiecare j din lista arbore[i] adicÄƒ fiecare j vecin al lui i executÄƒ \n\t dacÄƒ vizitat[j] = 0 atunci \n\t Parcurgere(j, arbore)"
                }
                , "value-solution": {
                    "title": "Determinarea soluÈ›iei È™tiind ciclul hamiltonian"
                    , "pseudocode": "Pseudocod Valoare_ciclu(ciclu) \n soluÈ›ie â† 0 \n pentru fiecare douÄƒ noduri x È™i y alÄƒturate Ã®n ciclu executÄƒ \n\t soluÈ›ie â† soluÈ›ie + d(x, y) \n returneazÄƒ soluÈ›ie"
                }
                , "bind": "\t AvÃ¢nd toate datele necesare, este nevoie sÄƒ se apeleze iniÈ›ial funcÈ›ia Prim(nod_start) pentru a determina arborele parÈ›ial de cost minim prin vectorul de tatÄƒ, apoi Ciclu_hamiltonian care primeÈ™te ca parametru arborele determinat. Aceasta calculeazÄƒ ciclul prin apelarea funcÈ›iei recursive Parcurgere. La final este nevoie de funcÈ›ia Valoare_ciclu(ciclu) pentru a determina valoarea ciclului primit ca parametru care este determinat Ã®n metoda anterioarÄƒ."
            }
            , "complexity": {
                "theorem": "\t Algoritmul arborelui dublu are complexitatea O(n + m log n)."
                , "functions-complexity": {
                    "0": "Prim: O(m log n) pentru cÄƒ foloseÈ™te coada de prioritÄƒÈ›i; per total sunt m inserÄƒri È™i maxim m extrageri Ã®n coadÄƒ, iar o inserare/extragere ia O(log n)"
                    , "1": "DFS: O(n + m); dar cum suntem Ã®ntr-un arbore, m = n - 1, deci complexitatea este O(n)"
                    , "2": "Determinarea soluÈ›iei: O(n)"
                }
            }
        }
        
        , "christofides-algorithm": {
            "title": "Algoritmul lui Christofides"
            , "header": "\t Algoritmul lui Christofides este 3/2 - aproximativ È™i este aplicabil pe cazul Ã®n care TSP este metric, fiind algoritmul de aproximare cu cel mai mic factor de aproximare Ã®n momentul de faÈ›Äƒ. Chiar dacÄƒ  pare o aproximare mare, 3/2 este pentru cazul cel mai nefavorabil È™i Ã®n practicÄƒ (Ã®n medie) algoritmul poate dÄƒ rezultate mai bune."
           
            , "steps-christofides": {
                "header": "ÃmbunÄƒtÄƒÈ›ire lui Chistofides:"
                , "prim": "Se porneÈ™te cu crearea arborelui de acoperire de cost minim"
                , "odd-nodes": "Fiind un arbore, este sigur ca are noduri impare (cel puÈ›in pentru cÄƒ are frunze), dar suma tuturor gradelor nodurilor rÄƒmÃ¢ne un numÄƒr par. Din aceastÄƒ afirmaÈ›ie, se ajunge la concluzia cÄƒ existÄƒ Ã®n arbore un numÄƒr par de noduri de cardinal impar. Se determinÄƒ aceste noduri"
                , "matching": "Determinarea potrivirii perfercte de cost minim (minimum perfect matching) aplicÃ¢nd algoritmul de determinare a unui cuplajul perfect: alegerea unor muchii care sÄƒ lipeascÄƒ nodurile de grad impar douÄƒ cÃ¢te douÄƒ. Muchiile alese de acest algoritm aplicat peste mulÈ›imea O se noteazÄƒ cu M."
                , "adding-nodes": "AdÄƒugarea noilor muchii ale potrivirii optime la arbore"
                , "determine-cycle": "Se determinÄƒ ciclul eulerian (trecerea prin toate muchiile) - nu se mai poate folosi DFS pentru ca muchiile nu mai sunt dublate"
                , "shortcuts": "Se aplicÄƒ tehnica de utilizare a scurtÄƒturilor "
                , "approximation": "\t Graful eulerian obÈ›inut are distanÈ›a total l(T) + l(M), iar dupÄƒ ce se aplicÄƒ tehnica de shortcut-uri ciclul hamiltonian rezultat nu va depÄƒÈ™i l(T) + l(M) â‰¤ 3/2 OPT"
                , "christofides-approximation-theorem": {
                    "0": "\t Algoritmul lui Christofides are factorul de aproximare de 3/2. \nDemonstraÈ›ie: Lungimea ciclului determinat de algoritmul lui Christofides nu depÄƒÈ™este l(T) + l(M) unde T este arborele de cost minim pentru care l(T) â‰¤ OPT È™i M este mulÈ›imea muchiilor alese de algoritmul de matching.  Acum ne axÄƒm atenÈ›ia pe l(M). \n\t Fie H un ciclu optimal care conÈ›ine nodurile din O. La trecerea prin H, se coloreazÄƒ pe rÃ¢nd o muchie cu roÈ™u È™i se adaugÄƒ Ã®n H1, apoi urmÄƒtoarea cu albastru È™i se adaugÄƒ Ã®n H2. H1  È™i H2 sunt potriviri perfecte. M este potrivirea perfectÄƒ de cost minim, aÈ™adar:"
                    , "1": "l(M) â‰¤ l(H1) \n l(M) â‰¤ l(H2) \n l(H1) + l(H2) = l(H) \n => 2 l(M) â‰¤ l(H) (a) \n H âŠ‚ G => l(H) â‰¤ OPT (b) \n din (a) È™i (b) => 2l(M) â‰¤ OPT, deci l(M) â‰¤ 1/2 OPT \n  l(T) + l (M) â‰¤ 3/2 OPT, algoritmul lui Christofides este 3/2 aproximativ."
                }
            }
            , "algorithm": {
                "prim": {
                    "title": "Prim"
                    , "text": "\t La fel ca la algoritmul arborelui dublu cu singura diferenÈ›Äƒ cÄƒ atunci cÃ¢nd se introduce muchia Ã®n arbore, se incrementeazÄƒ È™i de cÃ¢te ori s-a introdus muchia pentru a reÈ›ine astfel gradul nodurilor"
                } 
                , "odd-nodes": {
                    "title": "Determinarea nodurilor de grad impar"
                    , "text": "\t AvÃ¢nd la dispoziÈ›ie rezultatul funcÈ›iei Prim, se creeazÄƒ o listÄƒ Ã®n care se insereazÄƒ nodurile care au fost notate cu grad impar Ã®n vector"
                }
                , "matching": {
                    "title": "Determinarea cuplajului perfect"
                    , "version-greedy": {
                        "title": "Cuplajul perfect pe nodurile din O, determinÃ¢nd mulÈ›imea M de muchii folosind strategia greedy"
                        , "steps": "\t Strategia greedy este simplistÄƒ. Se extrage un nod u din lista de noduri de grad impar È™i se verificÄƒ care este cel mai apropiat nod j cu care se poate cupla dintre nodurile necuplate din listÄƒ. Acest nod j se seteazÄƒ ca pereche a nodului u (pereche_u). Se repetÄƒ modul de alegere pÃ¢nÄƒ cÃ¢nd nu mai existÄƒ noduri de grad impar." 
                        , "approximation": "\t Factorul de aproximare 3/2 este legat de folosirea cuplajului perfect de cost minim, aÈ™adar Ã®nlocuind acea metodÄƒ cu un cuplaj ce se bazeazÄƒ pe o alegere greedy, nu mai poate fi garantat factorul de aproximare. TotuÈ™i, pentru a oferi un cuplaj de pondere cÃ¢t mai micÄƒ, se repetÄƒ de un numÄƒr mai mare de ori algoritmul greedy, la final pÄƒstrÃ¢ndu-se varianta pentru care cuplajul are lungimea cea mai micÄƒ."
                       , "pseudocode": "Parametri de intrare: arbore noduri_grad_impar obÈ›inute cu algoritmul lui Prim, numÄƒrul de repetÄƒri stabilit \n copie â† copie a  vectorului de noduri de grad impar \n soluÈ›ie_minimÄƒ â† âˆ \n muchii â† listÄƒ vidÄƒ \n muchii_alese â† listÄƒ vidÄƒ \n pentru i â† 0, repetÄƒri - 1 executÄƒ \n\t potrivire â†  Fals \n\t cÃ¢t timp potrivire = Fals executÄƒ \n\t\t potrivire â† AdevÄƒrat \n\t\t se amestecÄƒ nodurile din noduri_grad_impar \n\t\t soluÈ›ie â† 0 \n\t\t cÃ¢t timp existÄƒ noduri Ã®n noduri_grad_impar executÄƒ \n\t\t\t u â† extrage un nod din noduri_grad_impar \n\t\t\t lungime_minimÄƒ â† âˆ \n\t\t\t pentru fiecare nod v rÄƒmas noduri_grad_impar executÄƒ \n\t\t\t\t dacÄƒ u â‰  v È™i d(u, v) < lungime_minimÄƒ È™i u È™i v nu erau deja vecini Ã®n arbore atunci \n\t\t\t\t\t lungime_minimÄƒ â† d(u, v) \n\t\t\t\t\t pereche_u â† v \n\t\t\t\t\t dacÄƒ s-a gÄƒsit o pereche lui u atunci \n\t\t\t\t\t\t adaugÄƒ muchia (u, pereche_u) la lista muchii\n\t\t\t\t\t\t soluÈ›ie â† soluÈ›ie + lungime_minimÄƒ \n\t\t\t\t\t\t se scoate È™i nodul pereche_u din lista noduri_grad_impar \n\t\t\t\t\t altfel \n\t\t\t\t\t\t potrivire â† Fals    // ultimele noduri sunt deja vecine Ã®n arbore, nu se pot Ã®mperechia din nou \n\t dacÄƒ soluÈ›ie < soluÈ›ie_minimÄƒ atunci \n\t\t soluÈ›ie_minimÄƒ â† soluÈ›ie \n\t\t muchii_alese â† muchii \n returneazÄƒ muchii_alese"
                        , "explications": "\t Pentru a nu se determina la fiecare repetarea a metodei acelaÈ™i cuplaj, lista nodurilor de grad impar se amestecÄƒ (linia 9 din pseudocod) adicÄƒ se doreÈ™te schimbarea poziÈ›iei nodurilor la fiecare Ã®ncercare de a determina cuplajul perfect minim. \n\t Chiar dacÄƒ existÄƒ un numÄƒr par de noduri peste care se doreÈ™te realizarea unui cuplaj perfect, pot exista noduri pentru care cuplarea este imposibilÄƒ deoarece acele noduri sunt deja legate printr-o muchie Ã®n arborele parÈ›ial de cost minim. Se observÄƒ Ã®n pseudocod o variabilÄƒ 'cuplaj' care este de tip boolean. Se porneÈ™te de la presupunerea cÄƒ se poate crea un cuplaj perfect (variabila 'cuplaj' ia valoarea True) È™i se È›ine evidenÈ›a dacÄƒ cuplajul determinat este perfect sau nu. DacÄƒ nu se poate gÄƒsi printre nodurile necuplate o pereche pentru nodul curent, 'cuplaj' devine False. Nu se acceptÄƒ mulÈ›imea de muchii gÄƒsite È™i se porneÈ™te din nou de la capÄƒt cÄƒutarea, instrucÈ›iune realizatÄƒ Ã®n prima structura repetitivÄƒ 'cÃ¢t timp...executÄƒ'. DacÄƒ Ã®n schimb cuplajul este perfect se iese din structura repetitivÄƒ È™i se verificÄƒ dacÄƒ suma muchiilor cuplajului determinat este minimÄƒ. AceastÄƒ metodÄƒ se repetÄƒ de repetÄƒri ori dupÄƒ care se returneazÄƒ lista de muchii (muchii_alese) pentru care suma muchiilor a fost minimÄƒ."
                    }
                    , "version-min-perfect-matching": {
                        "title": "Varianta care determinÄƒ muchiile potrivirii prin algoritmul de minim-cost perfect matching (factorul de aproximare este 3/2)"
                        , "description": "\t Metoda care creeazÄƒ cuplajul perfect de cost minim este una complexÄƒ ce se bazeazÄƒ pe algoritmul Blossom a lui Karp. Pentru a determina muchiile cuplajului perfect de cost minim existÄƒ funcÈ›ie predefinitÄƒ max_weight_matching din biblioteca NetworkX care dÃ¢ndu-i-se distanÈ›ele negate dintre nodurile de grad impar, returneazÄƒ o mulÈ›ime de perechi de noduri."
                        ,"reference": "Pentru mai multe detalii se recomandÄƒ accesarea cÄƒrÈ›ii"
                        , "book": "Combinatorial optimization scrisÄƒ de Korte È™i Vygen"
                    }
                }
                , "add-edges": {
                    "title": "AdÄƒugare muchii la arbore"
                    , "pseudocode": "pentru fiecare muchie de forma (u, v) din matching executÄƒ \n\t adaugÄƒ pe v la lista arbore[u] \n\t adaugÄƒ pe u la lista arbore[v] "
                }
                , "hamiltonian-cycle": {
                    "title": "Determinarea ciclului hamiltonian"
                    , "steps-eulerian-cycle": {
                        "header": "Sunt propuÈ™i urmÄƒtorii paÈ™i pentru a rezolva algoritmul lui Hierholzer (problemÄƒ ce rezolvÄƒ problema determinÄƒrii unui ciclu eulerian):"
                        , "0": "Se alege Ã®n mod aleator un nod de start u È™i se introduce ca prim nod la drum."
                        , "1": "Se adaugÄƒ noduri la drum mergÃ¢nd mereu doar pe muchii nevizitate pÃ¢nÄƒ se Ã®ntÃ¢lneÈ™te un nod din care nu se mai poate pleca."
                        , "2": "Se merge de la final spre Ã®nceput È™i se eliminÄƒ din coadÄƒ noduri care se insereazÄƒ Ã®ntr-o variabilÄƒ separatÄƒ notatÄƒ ciclu pÃ¢nÄƒ cÃ¢nd se ajunge Ã®ntr-un nod care mai are muchii adiacente nevizitate. Se repetÄƒ ultimii 2 paÈ™i pÃ¢nÄƒ cÃ¢nd nu se mai gÄƒsesc noduri nevizitate È™i toate nodurile sunt mutate Ã®n ciclu, creÃ¢ndu-se astfel ciclul care conÈ›ine toate muchiile."
                    }
                    , "add-hamiltonian-step": "\t Ciclu hamiltonian Ã®nseamnÄƒ cÄƒ din ciclul eulerian se eliminÄƒ nodurile cÃ¢nd se Ã®ntÃ¢lnesc din nou Ã®n ciclu. DacÄƒ la ultimul pas s-ar verifica dacÄƒ nodul este deja Ã®n variabila ciclu È™i s-ar insera nodul doar dacÄƒ nu a mai fost Ã®ntÃ¢lnit, Ã®nseamnÄƒ cÄƒ se creeazÄƒ ciclul hamiltonain Ã®n loc de cel eulerian (ceea ce ne si dorim)."
                    ,  "pseudocode": "fie k nodul de start \n drum â† [k] \n ciclu â† [] \n vizitat â† listÄƒ de lungime n iniÈ›ializatÄƒ cu 0 pe fiecare poziÈ›ie \n cÃ¢t timp existÄƒ noduri Ã®n drum executÄƒ \n\t nod_curent â† ultimul nod din drum \n\t dacÄƒ nod_curent nu are muchii neparcurse incidente atunci \n\t\t dacÄƒ vizitat[nod_curent] = 0 atunci \n\t\t\t adaugÄƒ nod_curent la ciclu \n\t\t\t vizitat[nod_curent] â† 1 \n\t\t dacÄƒ drum are un singur element atunci \n\t\t\t adaugÄƒ nod_curent la ciclu \n\t\t scoate nod_curent din drum \n\t altfel \n\t\t vecin â† vecin al lui nod_curent Ã®ntre care muchia este nevizitatÄƒ \n\t\t insereazÄƒ vecin Ã®n drum \n returneazÄƒ ciclu"

                }
                , "value-solution": {
                    "title": "Determinarea soluÈ›iei È™tiind ciclul hamiltonian"
                    , "text": "La fel ca la algoritmul arborelui dublu" 
                }
            }
            , "recommand-yt": "Pentru o bunÄƒ Ã®nÈ›elegere a modului de gÃ¢ndire È™i a paÈ™ilor prezentaÈ›i, se recomandÄƒ vizualizarea urmÄƒtorului curs: "
        }
    }
    , "heuristic-algorithms": {
        "header": "\t Algoritmii euristici de tio greedy sunt algoritmi buni ca performanÈ›Äƒ chiar dacÄƒ nu asigurÄƒ corectitudinea soluÈ›iei gÄƒsite È™i È™i nu garanteazÄƒ neapÄƒrat un anumit factor de aproximare constant È™i nu garanteazÄƒ neapÄƒrat un anumit factor de aproximare constant."
        , "build-cycle": {
            "title": "Construirea ciclului hamiltonian"
            , "header" : "\t Sunt prezentaÈ›i mai mulÈ›i algoritmi de determinare a unui ciclu hamiltonian de cost cÃ¢t mai mic. AceÈ™ti algoritmi de tip greedy construiesc un ciclu hamiltonian prin adÄƒugarea treptatÄƒ a cÃ¢te un nod la drumul curent construit, strategia de alegere fiind sugeratÄƒ de numele algoritmului."
            , "farthest-insertion": {
                "title": "Farthest Insertion - Algoritmul de inserÈ›ie a celui mai Ã®ndepÄƒrtat nod"
                , "header": "\t Algoritmul de inserÈ›ie a celui mai Ã®ndepÄƒrtat nod (farthest insertion) este  un algoritm de tip greedy Ã®n care se cautÄƒ, pentru a extinde ciclul construit pÃ¢nÄƒ la pasul curent, cel mai Ã®ndepÄƒrtat nod j faÈ›Äƒ de orice nod i din drum. Acesta se insereazÄƒ Ã®n drum pe poziÈ›ia care avantajeazÄƒ lungimea drumului, evitÃ¢ndu-se astfel adÄƒugarea unor muchii de lungime mare la drum. Matricea este completÄƒ È™i simetricÄƒ."
                , "worst-case": {
                    "title": "\tCazul cel mai nefavorabil"
                    , "text": "\t Algoritmul este 2 ln(n) + 0.16 aproximativ, aÈ™adar chiar È™i Ã®n cel mai rÄƒu caz:"
                    , "formula": "(soluÈ›ia FARTHEST) / OPT â‰¤ 2 ln(n) + 0.16"
                }
                , "pseudocode": {
                    "algorithm": {
                        "0" : "PaÈ™i algoritm"
                        , "1": "Se Ã®ncepe cu un nodul de start ales Ã®n mod aleator."
                        , "2": "Dintre toate nodurile nevizitate, se alege acela a cÄƒrui distanÈ›Äƒ minimÄƒ faÈ›Äƒ de nodurile din ciclu este maximÄƒ comparativ cu distanÈ›a celorlalte noduri nevizitate. Fie ciclul curent de forma (i1,i2,â€¦,i(k-1),ik,i1) È™i distanÈ›a(j) = min {d(i1, j), d(i2, j), â€¦, d(ik, j)},"
                        , "2-formula": "se alege j cu distanÈ›a(j) maximÄƒ."
                        , "3": "Se insereazÄƒ Ã®n ciclu nodul j pe poziÈ›ia q Ã®n care ar creÈ™te cel mai puÈ›in lungimea drumului, adicÄƒ "
                        , "3-formula": "poziÈ›ia q care are valoarea d(iq, j) + d(j, i(q+1)) - d(iq, i(q+1)) minimÄƒ."
                        , "4": "DacÄƒ ciclul nu conÈ›ine toate nodurile, se sare la pasul 2, alftel stop."
                    }
                    , "pseudocode": "se alege un nod random notat nod_start \n soluÈ›ie â† 0 \n ciclu â† [nod_start]  // listÄƒ Ã®n care se formeazÄƒ ciclul de distanÈ›Äƒ minimÄƒ; de reÈ›inut ca Ã®ntre nodurile indexate pe poziÈ›ii consecutive se aflÄƒ muchie \n h â† listÄƒ de lungime n Ã®n care se reÈ›in distanÈ›ele de la nodurile care nu fac parte din ciclu la ciclu \n pentru i â† 0, n - 1 executÄƒ \n\t dacÄƒ i != nod_start atunci \n\t h[i] â† d(nod_start, i) \n cÃ¢t timp ciclul nu are Ã®ncÄƒ n noduri executÄƒ \n\t reÈ›ine Ã®n k nodul atribuit valorii maxime din h È™tiind cÄƒ se iau Ã®n calcul doar nodurile nevizitate \n\t dacÄƒ ciclul este format dintr-un singur nod atunci \n\t\t introdu Ã®n ciclu nodul k \n\t\t marcheazÄƒ k ca vizitat \n\t\t soluÈ›ie â† 2 * h[k] \n\t altfel \n\t\t creÈ™tere_minimÄƒ â† âˆ \n\t\t m â† dimensiune ciclu \n\t\t pentru fiecare muchie (ciclu[i],  ciclu[(i+1) % m]) din ciclu executÄƒ \n\t\t\t a â† ciclu[i] \n\t\t\t b â† ciclu[(i+1) % m]) \n\t\t\t creÈ™tere â† d(a, k) + d(k, b) â€“ d(a, b) \n\t\t\t dacÄƒ creÈ™tere_minimÄƒ > creÈ™tere atunci \n\t\t\t\t creÈ™tere_minimÄƒ â† creÈ™tere \n\t\t\t\t poziÈ›ie_inserare â† i \n\t\t introdu Ã®n ciclu nodul k pe poziÈ›ia poziÈ›ie_inserare + 1 \n\t\t marcheazÄƒ k ca vizitat \n\t\t soluÈ›ie â† soluÈ›ie + creÈ™tere_minimÄƒ \n\t pentru i â† 0, n - 1 executÄƒ \n\t\t dacÄƒ i nu este vizitat È™i d(i, k) < h[i] atunci \n\t\t\t h[i] â† d(i, k) \n returneazÄƒ soluÈ›ie È™i ciclu"
                    , "explications": {
                        "text": "\t La Ã®nceput se genereazÄƒ nodul de start nod_start È™i se iniÈ›ializeazÄƒ h cu distanÈ›ele de la nod_start la orice alt nod din graf. La fiecare pas, valoarea soluÈ›iei È™i ciclul se actualizeazÄƒ, primind Ã®ncÄƒ un nod, nod ce corespunde celui mai Ã®ndepÄƒrtat nod de ciclu. DupÄƒ ce se determinÄƒ nodul de introdus notat cu k, trebuie sÄƒ se decidÄƒ poziÈ›ia optimÄƒ, adicÄƒ aceea care sÄƒ creascÄƒ valoarea soluÈ›iei cel mai puÈ›in. DupÄƒ actualizÄƒri, se necesitÄƒ È™i modificarea listei h, pentru a o aduce la starea curentÄƒ a ciclului, verificÃ¢nd dacÄƒ, prin introducerea nodului k, distanÈ›a de la nodurile nevizitate la ciclu se poate micÈ™ora. \n\t Algoritmul se Ã®ncheie cÃ¢nd ciclul creat conÈ›ine toate nodurile." 
                    }
                    , "vizualization": "\t PaÈ™ii de rulare ai algoritmului pe graf"
                }
                , "complexity": {
                    "theorem": "\t Algoritmul de inserÈ›ie a celui mai Ã®ndepÄƒrtat nod ruleazÄƒ Ã®n O(n^2). \n DemonstraÈ›ie: Structura repetitivÄƒ ce verificÄƒ dacÄƒ ciclul conÈ›ine toate nodurile executÄƒ n paÈ™i È™i Ã®n interiorul ei luarea informaÈ›iei din lista h È™i introducerea unor alte valori costÄƒ O(n), structura repetitivÄƒ Ã®n care se determinÄƒ poziÈ›ia potrivitÄƒ pentru inserarea nodului se executÄƒ Ã®n maxim O(n) È™i introducerea nodului Ã®n ciclu tot O(n). \n\t AÈ™adar, per total, interiorul stucturii se realizeazÄƒ Ã®n O(n) È™i Ã®mpreunÄƒ cu cele n repetÄƒri, rezultÄƒ complexitatea doritÄƒ O(n^2)."   
                }    
            } 
            , "nearest-insertion": {
                "title": "Nearest Insertion - Algoritmul de inserÈ›ie a celui mai apropiat nod"
                , "header": "\t Algoritmul de inserÈ›ie a celui mai apropiat nod (nearest insertion algorithm) este un algoritm de tip greedy care are ca scop determinarea unui ciclu hamiltonian de lungime minimÄƒ. Ciclul hamiltonian se construieÈ™te treptat pornind de la un singur nod, iar la fiecare pas dintre toate nodurile nevizitate se adaugÄƒ acela care este cel mai apropiat ca distanÈ›Äƒ faÈ›Äƒ de orice nod din ciclu, acesta fiind apoi introdus Ã®n ciclu pe poziÈ›ia care aduce cea mai micÄƒ creÈ™tere a lungimii ciclului."
                , "worst-case": {
                    "title": "\tCazul cel mai nefavorabil"
                    , "text": "\t Algoritmul este 2 aproximativ, aÈ™adar chiar È™i Ã®n cel mai rÄƒu caz:"
                    , "formula": "(soluÈ›ia NEAREST) / OPT â‰¤ 2"
                }
                , "pseudocode": {
                    "algorithm": {
                        "0" : "PaÈ™i algoritm"
                        , "1": "Se Ã®ncepe cu un nodul de start ales Ã®n mod aleator."
                        , "2": "Dintre toate nodurile nevizitate, se alege acela a cÄƒrui distanÈ›Äƒ minimÄƒ faÈ›Äƒ de nodurile din ciclul este minimÄƒ comparativ cu distanÈ›a celorlalte noduri nevizitate. Fie ciclul curent de forma (i1 ,i2, â€¦, i(k-1), ik, i1) È™i distanÈ›a(j) = min {d(i1,j), d(i2,j), â€¦, d(ik,j)}, "
                        , "2-formula": "se alege j cu distanÈ›a(j) minimÄƒ."
                        , "3": "Se insereazÄƒ Ã®n ciclu nodul j pe poziÈ›ia q Ã®n care ar creÈ™te cel mai puÈ›in lungimea drumului, adicÄƒ "
                        , "3-formula": "poziÈ›ia q care are valoarea d(iq,j) + d(j,i(q+1)) - d(iq,i(q+1)) minimÄƒ."
                        , "4": "DacÄƒ ciclul nu conÈ›ine toate nodurile, se sare la pasul 2, alftel stop."
                    }
                    , "pseudocode": "se alege un nod random notat nod_start \n soluÈ›ie â† 0 \n ciclu â† [nod_start]  // listÄƒ Ã®n care se formeazÄƒ ciclul de distanÈ›Äƒ minimÄƒ, iniÈ›ializatÄƒ cu nodul de start; de reÈ›inut ca Ã®ntre nodurile indexate pe poziÈ›ii consecutive se aflÄƒ muchie \n h â† listÄƒ de lungime n Ã®n care se reÈ›in distanÈ›ele de la nodurile care nu fac parte din ciclu la ciclu \n pentru i â† 0, n - 1 executÄƒ \n\t dacÄƒ i != nod_start atunci \n\t h[i] â† d(nod_start, i) \n cÃ¢t timp ciclul nu are Ã®ncÄƒ n noduri executÄƒ \n\t reÈ›ine Ã®n k nodul atribuit valorii minime din h È™tiind cÄƒ se iau Ã®n calcul doar nodurile nevizitate \n\t dacÄƒ ciclul este format dintr-un singur nod atunci \n\t\t introdu Ã®n ciclu nodul k \n\t\t marcheazÄƒ k ca vizitat \n\t\t soluÈ›ie â† 2 * h[k] \n\t altfel \n\t\t creÈ™tere_minimÄƒ â† âˆ \n\t\t m â† dimensiune ciclu \n\t\t pentru fiecare muchie (ciclu[i],  ciclu[(i+1) % m]) din ciclu executÄƒ \n\t\t\t a â† ciclu[i] \n\t\t\t b â† ciclu[(i+1) % m]) \n\t\t\t creÈ™tere â† d(a, k) + d(k, b) â€“ d(a, b) \n\t\t\t dacÄƒ creÈ™tere_minimÄƒ > creÈ™tere atunci \n\t\t\t\t creÈ™tere_minimÄƒ â† creÈ™tere \n\t\t\t\t poziÈ›ie_inserare â† i \n\t\t introdu Ã®n ciclu nodul k pe poziÈ›ia poziÈ›ie_inserare + 1 \n\t\t marcheazÄƒ k ca vizitat \n\t\t soluÈ›ie â† soluÈ›ie + creÈ™tere_minimÄƒ \n\t pentru i â† 0, n - 1 executÄƒ \n\t\t dacÄƒ i nu este vizitat È™i d(i, k) < h[i] atunci \n\t\t\t h[i] â† d(i, k) \n returneazÄƒ soluÈ›ie È™i ciclu"
                    , "explications": {
                        "text": "\t DupÄƒ cum se observÄƒ, seamanÄƒ cu algoritmul de inserÈ›ie a celui mai Ã®ndepÄƒrtat nod, diferenÈ›a fiind modul de selectare a noului nod care va fi introdus Ã®n ciclu. Prin urmare, È™i pseudocodul este acelaÈ™i Ã®n afarÄƒ de o comandÄƒ ce atribuia variabilei k nodul ce are distanÈ›a maximÄƒ din h luÃ¢nd Ã®n calcul doar nodurile nevizitate, acum k ia valoarea nodului cu distanÈ›a minimÄƒ." 
                    }
                    , "vizualization": "\t PaÈ™ii de rulare ai algoritmului pe graf"
                }  
                , "complexity": {
                    "theorem": "\t Algoritmul de inserÈ›ie a celui mai apropiat nod are complexitatea Ã®n O(n^2). \n DemonstraÈ›ie: Ãn afarÄƒ de modificarea specificatÄƒ, algoritmul funcÈ›ioneazÄƒ la fel, prin urmare È™i acesta se Ã®ncadreazÄƒ Ã®n O(n^2)."  
                } 
            }
            , "cheapest-insertion": {
                "title": "Cheapest Insertion - Algoritmul de inserÈ›ie cu cel mai mic cost"
                , "header" : "\t Algoritmul de inserÈ›ie cu cel mai mic cost (cheapest insertion algorithm) este un algoritm greedy care are ca scop determinarea unui ciclu hamiltonian de cost cÃ¢t mai mic. La fiecare pas, se introduce la ciclul curent nodul ce aduce distanÈ›ei ciclului cea mai micÄƒ creÈ™tere, introducÃ¢ndu-se nodul pe poziÈ›ia care Ã®l avantajeazÄƒ."
                , "worst-case": {
                    "title": "\tCazul cel mai nefavorabil"
                    , "text": "\t Algoritmul este 2 aproximativ, aÈ™adar chiar È™i Ã®n cel mai rÄƒu caz:"
                    , "formula": "(soluÈ›ia CHEAPEST) / OPT â‰¤ 2"
                }
                , "pseudocode": {
                    "algorithm": {
                        "0" : "PaÈ™i algoritm"
                        , "1": "Se Ã®ncepe cu un nodul de start ales Ã®n mod aleator."
                        , "2": "Dintre toate nodurile nevizitate, se alege acela care aduce cea mai micÄƒ creÈ™tere a lungimii ciclului dacÄƒ este introdus Ã®ntre douÄƒ noduri deja aflate Ã®n ciclu. Fie ciclul curent de forma (i1, i2, â€¦, i(k-1), ik, i1) È™i"
                        , "2-formula": "se alege j cu d(ip,j) + d(j,iq) - d(ip,iq) minimÄƒ, unde ip È™i iq sunt noduri consecutive."
                        , "3": "Se insereazÄƒ Ã®n ciclu nodul j"
                        , "3-formula": "Ã®ntre nodurile pentru care distanÈ›a adaugatÄƒ este minimÄƒ."
                        , "4": "DacÄƒ ciclul nu conÈ›ine toate nodurile, se sare la pasul 2, alftel stop."
                    }
                    , "pseudocode": "se alege un nod random notat nod_start \n ciclu â† [nod_start]  // listÄƒ Ã®n care se formeazÄƒ ciclul de distanÈ›Äƒ minimÄƒ, iniÈ›ializatÄƒ cu nodul de start; de reÈ›inut cÄƒ Ã®ntre nodurile alÄƒturate se aflÄƒ muchie \n h â† listÄƒ Ã®n care se reÈ›in triplete de forma [creÈ™tere, poziÈ›ie din stÃ¢nga locului Ã®n care ar fi adÄƒugat nodul k, k] \n determinÄƒ cel mai apropiat nod de nod_start È™i se noteazÄƒ cu k \n introdu Ã®n ciclu nodul k \n soluÈ›ie â† 2 * d(nod_start, k) \n pentru i â† 0, n - 1 executÄƒ \n\t dacÄƒ i != ciclu[0] È™i i != ciclu[1]: \n\t\t creÈ™tere â† d(ciclu[0], j) + d(j, ciclu[1]) - d(ciclu[0], ciclu[1]) \n\t\t adaugÄƒ la h tripletul [creÈ™tere, 0, i] \n cÃ¢t timp ciclul nu are Ã®ncÄƒ n noduri executÄƒ \n\t extrage din h tripletul cu creÈ™terea minimÄƒ È™i reÈ›ine valorile Ã®n creÈ™tere_minimÄƒ, poziÈ›ie_inserare, k \n\t introdu Ã®n ciclu nodul k pe poziÈ›ia poziÈ›ie_inserare + 1 \n\t marcheazÄƒ k ca vizitat \n\t soluÈ›ie â† soluÈ›ie + creÈ™tere_minimÄƒ \n\t m â† dimensiune ciclu \n\t pentru orice triplet din h de forma creÈ™tere, poziÈ›ie, nod executÄƒ \n\t\t dacÄƒ poziÈ›ie = poziÈ›ie_inserare sau nod = k atunci \n\t\t\t eliminÄƒ tripletul din h \n\t\t dacÄƒ poziÈ›ie > poziÈ›ie_inserare È™i nod nu este vizitat atunci \n\t\t\t poziÈ›ie â† (poziÈ›ie + 1) % m \n\t pentru i â† 0, n - 1 executÄƒ \n\t\t dacÄƒ i nu este vizitat atunci \n\t\t\t a â† ciclu[poziÈ›ie_inserare] \n\t\t\t b â† ciclu[(poziÈ›ie_inserare +2) % m]) \n\t\t\t adaugÄƒ la h tripletul [d(a, i) + d(i, k) - d(a, k), poziÈ›ie_inserare, i] \n\t\t\t adaugÄƒ la h tripletul [d(k, i) + d(i, b) - d(k, b), (poziÈ›ie_inserare+2) % m, i] \n returneazÄƒ soluÈ›ie È™i ciclu"
                    , "explications": {
                        "text": "\t IniÈ›ial se doreÈ™te crearea unui ciclu din douÄƒ noduri cu scopul de a-l extinde treptat. AÈ™adar, dupÄƒ ce a fost generat nodul de start nod_start, se cautÄƒ cel mai apropiat nod de acestÄƒ, numit k. Pentru cÄƒ este un ciclu, costul acestuia este de douÄƒ ori costul distanÈ›ei de la nod_start la k, iar mai apoi se introduce Ã®n lista h opÈ›iunile din care se va alege Ã®n viitor creÈ™terea minimÄƒ posibilÄƒ. \n\t Algoritmul ruleazÄƒ cÃ¢t timp ciclul nu are Ã®ncÄƒ n noduri, la fiecare pas extrÄƒgÃ¢ndu-se din h creÈ™terea minimÄƒ posibilÄƒ, respectiv locul Ã®n care se doreÈ™te inserarea nodului Ã®n ciclu È™i nodul k. Este nevoie sÄƒ se actualizeze valoarea soluÈ›iei È™i ciclul prin introducerea nodului gÄƒsit pe poziÈ›ia Ã®n care avantajeazÄƒ distanÈ›a ciclului. \n\t AvÃ¢nd Ã®n vedere cÄƒ nodul k devine parte din ciclu, trebuie sÄƒ se modifice lista h, eliminÃ¢ndu-se din ea tripletele care tratau nodul k precum un nod nevizitat È™i acelea care considerau cÄƒ Ã®ntre ip È™i iq nu a fost introdus un alt nod. AdicÄƒ tripletele pentru care distanÈ›a calculatÄƒ nu mai reflectÄƒ starea actualÄƒ a ciclului. De asemenea, trebuie sÄƒ se actualizeze poziÈ›ia de inserare pentru tripletele care vizeazÄƒ poziÈ›ii ce se aflÄƒ dupÄƒ poziÈ›ia extrasÄƒ din h. Aceasta deoarece, inserÃ¢nd nodul pe poziÈ›ia poziÈ›ie_inserare, toate celelalte noduri de dupÄƒ el se mutÄƒ mai la dreapta cu o poziÈ›ie. La final, se completeazÄƒ lista h cu triplete Ã®n care sunt calculate distanÈ›ele ce Ã®l includ È™i pe k la nodurile ciclului."
                    }
                    , "vizualization": "\t PaÈ™ii de rulare ai algoritmului pe graf"
                }  
                , "complexity": {
                    "theorem": "\t Algoritmul de inserÈ›ie cu cel mai mic cost ruleazÄƒ Ã®n O(n^2 log(n)). \n DemonstraÈ›ie: Pentru a eficientiza determinarea minimului din lista h, se lucreazÄƒ cu o listÄƒ de prioritÄƒÈ›i, operaÈ›iile de adÄƒugat È™i de scoatere a unui element costÃ¢nd O(log(n)). Determinarea celui mai apropiat nod de nodul de start costÄƒ O(n), iar inserarea Ã®n h a primelor triplete ruleaza Ã®n O(n log(n)). Timpul de execuÈ›ie O(n^2 log(n)) este dat Ã®nsÄƒ de structura repetitivÄƒ care se ruleazÄƒ de n ori È™i verificÄƒ dacÄƒ ciclul conÈ›ine toate nodurile. Ãn interiorul ei extragerea din h a tripletului minim necesitÄƒ O(log(n)), actualizarea ciclului O(n), eliminarea È™i adÄƒugare de triplete Ã®n lista de prioritÄƒÈ›i O(n log(n)). \n\t ConcluzionÃ¢nd, interiorul structurii repetitive ruleazÄƒ Ã®n O(n log(n)) È™i se repetÄƒ de n ori, rezultÃ¢nd complexitatea O(n^2 log(n))."
                } 
            }
            , "nearest-neighbor": {
                "title": "Nearest neighbor - Algoritmul cel mai apropiat vecin"
                , "header" : "\t Cel mai simplu algoritm euristic este algoritmul cel mai apropiat vecin (nearest neighbor algorithm, NN). DÃ¢ndu-se un graf complet cu ponduri ne-negative, se determinÄƒ un ciclu hamiltonian Ã®n care nodurile sunt alese Ã®n funcÈ›ie de apropierea dintre ele. AÈ™adar, la fiecare pas se introduce la drumul curent nodul care nu face Ã®ncÄƒ parte din el È™i care este cel mai aproape ca distanÈ›Äƒ de ultimul nod din drum." 
                , "worst-case": {
                    "title": "\tCazul cel mai nefavorabil"
                    , "text": "\t Algoritmul este 1/2 ln(n) + 1/2 aproximativ, aÈ™adar chiar È™i Ã®n cel mai rÄƒu caz:"
                    , "formula": "(soluÈ›ia NN) / OPT â‰¤ 1/2 ln(n) + 1/2"
                }
                , "pseudocode": {
                    "algorithm": {
                        "0" : "PaÈ™i algoritm"
                        , "1": "Se Ã®ncepe cu un nodul de start ales Ã®n mod aleator."
                        , "2": "Dintre toate nodurile nevizitate, se alege acela care este cel mai aproape de ultimul nod din drum. Fie drumul curent de forma (i1, i2, â€¦, i(k-1), ik) È™i"
                        , "2-formula": "se alege j cu distanÈ›a d(ik, j) minimÄƒ."
                        , "3": "Se insereazÄƒ "
                        , "3-formula": "nodul j la finalul drumului."
                        , "4": "DacÄƒ drumul nu conÈ›ine toate nodurile, se sare la pasul 2, alftel stop."
                    }
                    , "pseudocode": "se alege un nod random notat nod_start È™i se seteazÄƒ ca primul nod din ciclu \n valoare_ciclu â† 0 \n i â† nod_start \n cÃ¢t timp existÄƒ noduri nevizitate executÄƒ \n\t pentru nodul curent i introdu Ã®n ciclu nodul j nevizitat cu d(i, j) minim \n\t valoare_ciclu â† valoare_ciclu + d(i, j) \n\t marcheazÄƒ j ca vizitat \n\t i â† j \n valoare_ciclu â† valoare_ciclu + d(i, nod_start) \n returneazÄƒ ciclul creat È™i valoare_ciclu" 
                    , "vizualization": "\t PaÈ™ii de rulare ai algoritmului pe graf"
                }  
                , "complexity": {
                    "theorem": "\t Complexitatea algoritmului NN este O(n^2). \n DemonstraÈ›ie: Algoritmul este simplist, complexitatea fiindu-i determinatÄƒ de necesitatea repetÄƒrii structurii repetive pÃ¢nÄƒ cÃ¢nd Ã®n drum sunt toate cele n noduri, aÈ™adar acest loop costÄƒ O(n). La fiecare pas, trebuie sÄƒ se determine nodul cel mai apropiat de ultimul nod din drum, operaÈ›ie care se efectueazÄƒ Ã®n O(n). AÈ™adar per total algoritmul ruleazÄƒ Ã®n O(n^2)."
                } 
            }
            , "not-optimal-solution": "\t Algoritmii prezentaÈ›i nu sunt exacÈ›i, factorul de aproximare fiind menÈ›ionat pentru fiecare algoritm Ã®n parte, Ã®n subsecÈ›iunea respectivÄƒ. Ne dorim o valoare cÃ¢t mai apropiatÄƒ de cea optimÄƒ, prin urmare ciclul hamiltonian determinat este Ã®mbunÄƒtÄƒÈ›it Ã®n algoritmii 2-OPT È™i 3-OPT. Scopul acestor algoritmi este Ã®mbunÄƒtÄƒÈ›irea soluÈ›iei prin optimizarea ciclului determinat."   
        }
        , "cycle-improvement": {
            "title": "Optimizarea ciclului hamiltonian: k-OPT"
            , "header": "\t Pentru crearea ciclului hamiltonian se poate folosi unul dintre algoritmii prezentaÈ›i. AvÃ¢nd ciclul, urmÄƒtorul pas este Ã®mbunÄƒtÄƒÈ›irea costului lui pÃ¢nÄƒ cÃ¢nd nu se mai poate. La final nu se poate garanta cÄƒ ciclul obÈ›inut este minim. Reluarea algoritmului de mai multe ori folosind cicluri posibil diferite duce la creÈ™terea probabilitÄƒÈ›ii gÄƒsirii soluÈ›iei minime."
            , "definition-k-change-neighborhood": "\t Fie F mulÈ›imea tuturor ciclurilor hamiltoniane. O vecinÄƒtate este o mapare N : F â†’ 2^F Ã®n care N mapeazÄƒ fiecare f âˆˆ F Ã®n vecinÄƒtatea N(f). Lin propune vecinÄƒtÄƒÈ›ile pentru un TSP pe K_n. Pentru f un ciclu È™i k âˆˆ {2,...,n}, N(f) este mulÈ›imea tuturor ciclurilor hamiltoniene g care sunt obÈ›inute din f prin eliminarea a k muchii È™i Ã®nlocuirea lor cu k muchii (nu neapÄƒrat toate muchiile adÄƒugate trebuie sÄƒ fie diferite de cele eliminate). N(f) poartÄƒ numele de vecinÄƒtate k-schimburi (k-change neighborhood), iar oricare g a cÄƒrui distanÈ›Äƒ este minimÄƒ dintre toate celelalte cicluri din N(f) se numeÈ™te k-optimal."
            , "pseudocode": "Pseudocod k-OPT(D) \n alege un ciclu initial f \n cÃ¢t timp existÄƒ g âˆˆ N(f) cu d(g) < d(f) executÄƒ \n\t alege g âˆˆ N(f) cu d(g) < d(f) \n\t f â† g"
            , "explications": {
                "text": "\t Se considerÄƒ o mulÈ›ime de soluÈ›ii N(f) care sunt vecine cu soluÈ›ia curentÄƒ f È™i se cautÄƒ, din aceastÄƒ mulÈ›ime, optimul local, ciclul g care aduce cea mai Ã®nsemnatÄƒ Ã®mbunÄƒtÄƒÈ›ire. Algoritmul se opreÈ™te cÃ¢nd nu se mai gÄƒseÈ™te niciun optim local. AÈ™adar, dacÄƒ ciclul hamiltonian curent nu are vecini care sÄƒ ofere o soluÈ›ie mai bunÄƒ se considerÄƒ cÄƒ nu se mai poate optimiza." 
            }
            , "complexity": {
                "theorem": "\t Chiar dacÄƒ existÄƒ multe cicluri posibile, numÄƒrul lor este finit. DupÄƒ fiecare iteraÈ›ie a algoritmului k-OPT, se produce un ciclu hamiltonian cu lungime strict mai micÄƒ ca cel precedent, prin urmare ciclurile nu se pot repeta. \n\t Timpul de rulare este dat de numÄƒrul de iteraÈ›ii a ciclului principal â€cÃ¢nd timpâ€ Ã®nmulÈ›it cu numÄƒrul de operaÈ›ii realizate de o iteraÈ›ie. AvÃ¢nd Ã®n vedere cÄƒ sunt n noduri, existÄƒ O(n^k)    k-schimburi care trebuie verificare la fiecare iteraÈ›ie (k reprezentÄƒ numÄƒrul de muchii care vor fi Ã®nlocuire, prin urmare variazÄƒ Ã®n funcÈ›ie de problema pentru care se doreÈ™te rezolvare). Problema apare la numÄƒrul total de iteraÈ›ii care poate ajunge sÄƒ fie exponenÈ›ial, acesta depinzÃ¢nd de ciclul hamiltonian iniÈ›ial È™i de setul de date primit ca input."
            }
            , "2-opt": {
                "title": "Algoritmul 2-OPT"
                ,"header": "\t Algoritmul presupune optimizarea algoritmului prin aplicare de 2-schimburi, prin urmare ciclul hamiltonian creat la primul pas continuÄƒ sÄƒ fie modificat prin schimbarea a 2 muchii, producÃ¢nd un ciclu nou g care este mai bun sau mai puÈ›in optim ca cel original."
                , "advantage": {
                    "title": "Avantajul ciclului nou g comparativ cu ciclul anterior f"
                    , "formula": "Î´(g) = d(m1) + d(m2) - d(m1') - d(m2')"
                    , "explication": "\t DacÄƒ Î´(g) > 0 Ã®nseamnÄƒ cÄƒ s-a gÄƒsit un ciclu de lungime mai micÄƒ adicÄƒ s-a produs o Ã®mbunÄƒtÄƒÈ›ire. Algoritmul alege ciclul g vecin al lui f care are avantajul cel mai mare adicÄƒ cel care are lungimea ciclului cea mai micÄƒ." 
                }
                , "pseudocode-advantage": {
                    "text": "\t Fie calcul_avantaj funcÈ›ia care determinÄƒ avantajul aplicÄƒrii unui 2-schimb asupra unui ciclu. Ãi sunt date ca parametri ciclul f È™i cele 2 muchii pentru care se doreÈ™te sÄƒ se calculeze avantajul care se obÈ›ine dacÄƒ s-ar aplica 2-schimbul cu cele 2 muchii peste f. Scopul acestei metode este sÄƒ se verifice dacÄƒ este necesar sÄƒ se creeze noul ciclu g."
                    ,"pseudocode": "Pseudocod calcul_avantaj((x, y), (x', y')) \n calculeazÄƒ Î´ â† d(x, y) + d(x', y') - d(x, x') - d(y, y') \n returneazÄƒ Î´"
                }
                , "pseudocode-2-change": {
                    "text": "\t Fie 2Schimburi funcÈ›ia care determinÄƒ un ciclu g vecin cu f È™i valoarea lui Î´. Ãi sunt date ca parametri ciclul f de la care se porneÈ™te È™i cele 2 muchii pentru care se doreÈ™te modificarea."
                    , "pseudocode": "Pseudocod 2Schimburi(f, (x, y), (x', y')) \n Ã®nlÄƒturÄƒ din f muchiile (x, y) È™i (x', y') care nu au niciun nod comun \n adaugÄƒ Ã®n f muchiile (x, x') È™i (y, y'), pereche de muchii care duce la crearea unui nou ciclu g \n returneazÄƒ noul ciclu g"
                }
                , "pseudocode-2-opt": {
                    "text": "\t Din algoritmul euristic È™i metodele calcul_avantaj È™i 2Schimburi se creeazÄƒ algoritmul dorit 2-OPT care are ca scop determinarea ciclului de lungime cÃ¢t mai micÄƒ prin modificarea ciclului iniÈ›ial."
                    , "pseudocode": "Pseudocod 2-OPT \n f, soluÈ›ie â† NN(D) \n repetÄƒ \n\t Î´ â† 0 \n\t g â† f \n\t pentru fiecare m1, m2 din f, muchii care nu au niciun nod comun executÄƒ \n\t\t Î´g â† calcul_avantaj(m1, m2) \n\t\t dacÄƒ Î´g > Î´ atunci \n\t\t\t g â† 2Schimburi(f, m1, m2) \n\t\t\t Î´ â† Î´g \n\t f â† g \n\t soluÈ›ie â† soluÈ›ie - Î´ \n pÃ¢nÄƒ cÃ¢nd Î´ = 0 \n returneazÄƒ soluÈ›ie"
                }
                , "pseudocode-bind": {
                    "text": "\t Pentru a ajunge la o soluÈ›ie cÃ¢t mai bunÄƒ, 2-OPT este apelatÄƒ de 'repetÄƒri' ori cu scopul de a ajunge la soluÈ›ia optimÄƒ prin optimizarea a mai multor cicluri obÈ›inute prin metoda NN. Prin urmare, soluÈ›ia minimÄƒ din aceste repetÄƒri rulÄƒri ale algoritmului este consideratÄƒ soluÈ›ia optimÄƒ."
                    , "pseudocode": "soluÈ›ie_minimÄƒ â† âˆ \n pentru i â† 1, repetÄƒri executÄƒ \n\t soluÈ›ie â† 2-OPT \n\t dacÄƒ soluÈ›ie < soluÈ›ie_minimÄƒ atunci \n\t\t soluÈ›ie_minimÄƒ â† soluÈ›ie"
                }
            }
            , "3-opt": {
                "title": "Algoritmul 3-OPT"
                , "header": "\t Algoritmul 3-OPT are aceeaÈ™i structurÄƒ de rezolvare, diferenÈ›a faÈ›Äƒ de algoritmul 2-OPT este funcÈ›ia care calculeazÄƒ avantajul realizÄƒrii unui schimb, fiind adaptatÄƒ pentru noul tip de Ã®nlocuire, È™i funcÈ›ia Ã®n care se realizeazÄƒ cicluri prin 2-schimburi, acum prin 3-schimburi. Conceptul de Ã®nlocuire rÄƒmÃ¢ne acelaÈ™i: un 3-schimb Ã®nseamnÄƒ cÄƒ se aplicÄƒ 2-schimb pe un ciclu de unul sau mai multe ori pentru cÄƒ sunt la dispoziÈ›ie 3 muchii. AÈ™adar dintr-un ciclu se creeazÄƒ 7 alte cicluri È™i dintre acestea se alege cel care are avantajul maxim."
                , "cycles-created-with-3-change": {
                    "0": "Cele 7 cicluri se creeazÄƒ astfel:"
                    , "1": "3 cicluri prin aplicarea 2-schimburi pe cÃ¢te 2 din cele 3 muchii" 
                    , "2": "3 cicluri prin aplicarea repetatÄƒ de 2 ori a douÄƒ perechi de muchii"
                    , "3": "1 ciclu prin aplicarea tuturor combinaÈ›iilor posibile din cele 3 muchii"
                }
                , "example": {
                    "step-1-part-1":  "\t Fie f ciclul iniÈ›ial de formÄƒ "
                    ,"cycle-1": "A â†’ B â†’ C â†’ D â†’ E â†’ F."
                    ,"step-1-part-2": "Se considerÄƒ ca nodul A se aflÄƒ pe poziÈ›ia i, nodul C pe poziÈ›ia j È™i nodul E pe poziÈ›ia k È™i se prezintÄƒ modul Ã®n care se realizeazÄƒ un 3-schimb prin aplicarea a douÄƒ 2-schimburi. \n\t IniÈ›ial se schimbÄƒ muchiile reÈ›inute pe poziÈ›ii (i, i + 1) È™i (j, j + 1), iar apoi a muchiilor de pe poziÈ›iile (i, i + 1) È™i (k, k + 1)."
                    , "step-2-part-1": "Se apeleazÄƒ funcÈ›ia 2Schimburi cu parametri f, AB, CD È™i se obÈ›ine ciclul g de forma "
                    , "cycle-2": "A â†’ C â†’ B â†’ D â†’ E â†’ F."
                    ,"step-2-part-2": "Deci acum pe poziÈ›iile (i, i + 1) se aflÄƒ muchia AC, pe poziÈ›iile (j, j + 1) muchia BD È™i pe (k, k + 1) EF."
                    , "step-3": "Se apeleazÄƒ funcÈ›ia 2Schimburi cu parametri g, AC, EF È™i se obÈ›ine ciclul dorit h care aratÄƒ astfel "
                    , "cycle-3": "A â†’ E â†’ D â†’ B â†’ C â†’ F."
                    , "step-4": "avantajul Î´ = d(AB) + d(CD) + d(EF) - d(AE) - d(BD) - d(CF). "
                }   
                , "pseudocode-advantage": "Pseudocod calcul_avantaj(AB, CD, EF) \n Î´(A â†’ C â†’ B â†’ D â†’ E â†’ F)  â† d(AB) + d(CD) - d(AC) - d(BD) \n Î´(A â†’ E â†’ D â†’ C â†’ B â†’F)  â† d(AB) + d(EF) - d(AE) - d(BF) \n Î´ (A â†’ B â†’ C â†’ E â†’ D â†’F)  â† d(CD) + d(EF) - d(CE) - d(DF) \n Î´ (A â†’ C â†’ B â†’ E â†’ D â†’F)  â† d(AB) + d(CD) + d(EF) - d(AC) - d(BE) - d(DF) \n Î´ (A â†’ E â†’ D â†’ B â†’ C â†’F)  â† d(AB) + d(CD) + d(EF) - d(AE) - d(DB) - d(CF) \n Î´ (A â†’ D â†’ E â†’ C â†’ B â†’F)  â† d(AB) + d(CD) + d(EF) - d(AD) - d(EC) - d(BF) \n Î´ (A â†’ D â†’ E â†’ B â†’ C â†’F)  â† d(AB) + d(CD) + d(EF) - d(AD) - d(EB) - d(CF) \n se alege avantajul maxim È™i se noteazÄƒ cu Î´ \n returneazÄƒ Î´ È™i un identificator unic prin care sÄƒ se poatÄƒ recunoaÈ™te cÄƒrui schimb Ã®i corespunde avantajul"
                 
                , "pseudocode-3-change": {
                    "pseudocode": "Pseudocod 3Schimburi(f, AB, CD, EF, identificator) \n dacÄƒ identificator = 'ACBDEF' atunci \n\t g â† 2Schimburi(f, AB, CD) \n dacÄƒ identificator = 'AEDCBF' atunci \n\t g â† 2Schimburi(f, AB, EF) \n dacÄƒ identificator  = 'AEDCBF' atunci \n\t g â† 2Schimburi(f, CD, EF) \n dacÄƒ identificator = 'ACBEDF' atunci \n\t g_auxâ† 2Schimburi(f, AB, CD) \n\t g â† 2Schimburi(g_aux, AB, EF) \n dacÄƒ identificator = 'AEDBCF' atunci \n\t g_auxâ† 2Schimburi(f, AB, CD) \n\t g â† 2Schimburi(g_aux, CD, EF) \n dacÄƒ identificator = 'ADECBF' atunci \n\t g_auxâ† 2Schimburi(f, AB, EF)\n\t g â† 2Schimburi(g_aux, CD, EF) \n dacÄƒ identificator = 'ADEBCF' atunci \n\t g_1â† 2Schimburi(f, AB, CD) \n\t g_2 â† 2Schimburi(g_1, AB, EF) \n\t g â† 2Schimburi(g_2, CD, EF) \n returneazÄƒ ciclu g"
                    , "initial-text": "\t Se considerÄƒ identificator ordinea nodurilor Ã®n ciclul rezultat. Prin urmare, funcÈ›ia 3Schimburi aratÄƒ astfel: "
                    , "final-text": "\t Ãn primele trei condiÈ›ii din pseudocod se calculeazÄƒ cele trei 2-schimburi, Ã®n urmÄƒtoarele 3 cele trei cicluri obÈ›inute prin aplicarea a douÄƒ 2-schimburi care se realizeazÄƒ Ã®n 2 etape È™iÃ®n ultima ciclul construit prin trei 2-schimburi. Identificatorul decide pe ce condiÈ›ie se va intra creÃ¢ndu-se un singur ciclu care la final se returneazÄƒ."
                }
                , "pseudocode-3-opt": "Pseudocod 3-OPT \n f, soluÈ›ie â† NN(D) \n repetÄƒ \n\t Î´ â† 0 \n\t g â† f \n\t pentru fiecare m1, m2, m3 din  f, muchii care nu au niciun nod comun executÄƒ \n\t\t Î´g, identificator â† calcul_avantaj(m1, m2, m3) \n\t\t dacÄƒ Î´g > Î´ atunci \n\t\t\t g â† 3Schimburi(f, m1, m2, m3, identificator) \n\t\t\t Î´ â† Î´g \n\t f â† g \n\t soluÈ›ie â† soluÈ›ie - Î´ \n pÃ¢nÄƒ cÃ¢nd Î´ = 0 \n returneazÄƒ soluÈ›ie"
                , "pseudocode-bind": {
                    "text": "\t AvÃ¢nd Ã®n vedere cÄƒ È™i algoritmul 3-OPT, la fel ca algoritmul 2-OPT, presupune micÈ™orarea soluÈ›iei unui ciclu determinat de un algoritm aproximativ a cÄƒrui nod de start este ales aleator, este posibil ca 3-OPT sÄƒ nu ofere o soluÈ›ie bunÄƒ din cauza acelui ciclu iniÈ›ial. Pentru a avea mai multe È™anse, se poate rula de mai multe ori algoritmul È™i sÄƒ se pÄƒstreze ciclul cu soluÈ›ia cea mai micÄƒ."
                    , "pseudocode": "soluÈ›ie_minimÄƒ â† âˆ \n pentru i â† 1, repetÄƒri executÄƒ \n\t soluÈ›ie â† 3-OPT \n\t dacÄƒ soluÈ›ie < soluÈ›ie_minimÄƒ atunci \n\t\t soluÈ›ie_minimÄƒ â† soluÈ›ie"
                }
            }
        }
    }
    , "input-class": {
        "title": "Clasa Input"
        , "header": "\t ToÈ›i algoritmii prezentaÈ›i au ca input date introduse de utilizator. Inputul trebuie preluat de un algoritm, prelucrat È™i dat mai departe claselor care rezolvÄƒ TSP. Clasa care face acest lucru este numitÄƒ Input, ea fiind cea care aruncÄƒ erori Ã®n cazul Ã®n care datele introduse nu corespund celor necesare rezolvÄƒrii problemei sau tipului de instanÈ›Äƒ aleasÄƒ de utilizator."
        , "rules-title": "\t ListÄƒ de erori posibile È™i motivele pentru care sunt ridicate"
        , "rules": {
                "general": {
                    "title": "Erori ce pot apÄƒrea indiferent de tipul de instanÈ›Äƒ aleasÄƒ"
                    ,"0": {
                        "error": "The entered input does not have the correct form!",
                        "explication":"Se aÈ™teaptÄƒ 3 * n + 2 valori pentru ca inputul sÄƒ fie acceptat! Pe prima linie trebuie sÄƒ existe 2 numere pozitive Ã®ntregi, iar urmÄƒtoarele linii sÄƒ conÈ›inÄƒ triplete de tipul nod_1 nod_2 distanÈ›Äƒ."
                    }
                    , "1": {
                        "error": "You entered at least one negative number!"
                        , "explication": "S-a gÄƒsit cel puÈ›in un semn '-' printre datele introduse tripletelor. TSP nu acceptÄƒ ponderi negative È™i nodurile, prin convenÈ›ie, sunt numerotate de la 0 la n - 1 unde n este numÄƒrul de noduri."
                    }
                    , "2": {
                        "error": "Nodes are numbered from 0 to {0}, but node {1} was found!"
                        , "explication": "Prin convenÈ›ei s-a decis ca nodurile grafului sÄƒ fie numerotate de la 0 la n unde n este numÄƒrul de noduri. Nu conteazÄƒ ordinea specificÄƒrii acestora Ã®n triplete, dar nu se poate introduce noduri cu etichetÄƒ mai mare sau egalÄƒ cu n."
                    }
                }
                ,"oriented-graph": {
                    "title": "InstanÈ›a corespunde unui graf orientat care se transformÄƒ Ã®ntr-o matrice nesimetricÄƒ È™i nu neapÄƒrat completÄƒ"
                    , "0": {
                        "error": "The specified number of edges ({0}) is different from the number of lines of the type: node 1 node 2 value ({1})"
                        , "explication": "A doua valoare introdusÄƒ simbolizeazÄƒ numÄƒrul de muchii din graf care este echivalent cu numÄƒrul de triplete introduse de utilizator. Eroarea apare cÃ¢nd valoarea specificatÄƒ nu este egalÄƒ cu numÄƒrul de triplete." 
                    }
                    , "1": {
                        "error": "Already set the distance from node {0} to {1}!"
                        , "explication": "Fiecare distanÈ›Äƒ dintre douÄƒ noduri i È™i j se poate stabili o singurÄƒ datÄƒ"
                    } 
                }
                , "neoriented-graph": {
                    "title":"InstanÈ›a corespunde unui graf neorientat care se transformÄƒ Ã®ntr-o matrice simetricÄƒ È™i completÄƒ"
                    ,"0": {
                        "error": "The specified number of edges ({0}) is different from the number of lines of the type: node 1 node 2 value ({1})"
                        , "explication": "NumÄƒrul de triplete nu este acelaÈ™i ca numÄƒrul de muchii specificate" 
                    }
                    , "1": {
                        "error": "Already set the distance from node {0} to {1}!"
                        , "explication": "Fiecare distanÈ›Äƒ dintre douÄƒ noduri i È™i j se poate stabili o singurÄƒ datÄƒ"
                    } 
                    ,"2": {
                        "error": "The given graph is not complete!"
                        ,"explication": "Algoritmii de aproximare È™i cei euristici necesitÄƒ ca datele introduse sÄƒ corespundÄƒ unui graf complet. AÈ™adar dacÄƒ inputul este introdus pentru unul din aceste tipuri de algoritmi, se verificÄƒ dacÄƒ este specificatÄƒ o pondere Ã®ntre oricare douÄƒ noduri"
                    } 
                    ,"3": {
                        "error": "The given set of data does not transform to a matrix that respect the triangle inequality!"
                        ,"explication": "Algoritmii de aproximare È™i cei euristici necesitÄƒ ca datele introduse sÄƒ corespundÄƒ unui graf care respecte inegalitatea triunghiului (rezolvÄƒ TSP Ã®n cazul metric). AÈ™adar dacÄƒ inputul este introdus pentru unul din aceste tipuri de algoritmi, se cere ca distanÈ›ele din matricea creatÄƒ sÄƒ respecte inegalitatea triunghiulu"
                    } 
                }
                , "euclidean-distances": {
                    "title":"InstanÈ›a corespunde unor puncte din planul 2D. Se transformÄƒ Ã®ntr-o matrice simetricÄƒ pentru care distanÈ›a dintre oricare 2 noduri reprezintÄƒ distanÈ›a dintre acele puncte Ã®n plan. La final, matricea este completÄƒ"
                    ,"0": {
                        "error": "The number of nodes is different than specified!"
                        ,"explication": "Apare Ã®n cazul inputurilor Ã®n care numÄƒrul de triplete nu este acelaÈ™i ca numÄƒrul de muchii specificate."
                    }
                    , "1": {
                        "error": "Already set the coordonates for node {0}!"
                        , "explication": "Indexele nodurilor introduse nu sunt unice (se repetÄƒ de cel puÈ›in 2 ori valoarea din prima poziÈ›ie din triplete)"
                    }
                    , "2": {
                        "error": "Can not have the same coordonates for 2 different nodes!"
                        , "explication": "Au fost inserare douÄƒ (sau mai multe) noduri diferite cu aceleaÈ™i coordonate (se repetÄƒ de cel puÈ›in 2 ori combinaÈ›ia dintre a doua È™i a treia valoare din triplete)"
                    }
                } 
            
        }    
    }
    , "code-section": {
        "title": "TesteazÄƒ codul"
        , "explications-nodes-with-distance-symmetrical": "Pe prima linie introdu n = numÄƒrul de noduri È™i m = numÄƒrul de muchii \n Pe urmÄƒtoarele m linii introdu triplete de tipul: nod 1 nod 2 distanÈ›Äƒ (numÄƒrÄƒtoarea nodurilor Ã®ncepe de la 0) corespunzÄƒtoare unui graf neorientat complet."
        , "explications-nodes-with-distance-asymmetrical": "Pe prima linie introdu n = numÄƒrul de noduri È™i m = numÄƒrul de muchii \n Pe urmÄƒtoarele m linii introdu triplete de tipul: nod 1 nod 2 distanÈ›Äƒ (numÄƒrÄƒtoarea nodurilor Ã®ncepe de la 0) corespunzÄƒtoare unui graf orientat."
        , "explications-euclidian-distance": "Se precizeazÄƒ pe prima linie numÄƒrul de noduri È™i pe restul liniilor se gÄƒsesc triplete de tipul nod coordonata X coordonata Y (nodurile se numeroteazÄƒ Ã®ncepÃ¢nd cu 0). Se construieÈ™te un graf complet Ã®n care ponderile muchiilor sunt distanÈ›ele dintre punctele respective."
        , "placeholder": "Introdu datele aici..."
        , "solution": {
            "name": "SoluÈ›ie"
            , "wait": "AÈ™teptaÈ›i rÄƒspunsul!"
            , "insert-data": "Introdu un input Ã®nainte de a rula!"
            , "initial-text": "Aici apare rÄƒspunsul"
            , "no-solution": "Nu existÄƒ soluÈ›ie pentru graful dat!"
        } 
        , "number-repetitions": "NumÄƒr repetÄƒri"
        , "hamiltonian-cycle": "Ciclu hamiltonian"
        , "buttons": {
            "show-input-area": "TesteazÄƒ codul"
            , "hide-input-area": "Ascunde testarea"
            , "choose-euclidian": "DistanÈ›e euclidiene"
            , "choose-distance-between-symmetric-graph":  "Se È™tiu distanÈ›ele dintre noduri - graf neorientat"
            , "choose-distance-between-asymmetric-graph": "Se È™tiu distanÈ›ele dintre noduri - graf orientat"
            ,  "run-code": "RuleazÄƒ"
        }
        , "dynamic-programming": "Matricea M rezultatÄƒ de rularea programului"
        , "branch-and-bound": {
            "initial-matrix": "Prezentarea primilor 2 paÈ™i ai rulÄƒrii programului. Matricea iniÈ›ialÄƒ Ã®n care valoarea lim = "
            , "first-step-matrix": {
                "0": "Matricea redusÄƒ corespunzÄƒtoare nodului de start"
                , "1": " duce la valoarea lim = "
            } 
            , "second-step-matrix": {
                "0": "Matricea redusÄƒ corespunzÄƒtoare nodului"
                , "1": "plecÃ¢nd din nodul de start"
                , "2": " duce la valoarea lim = "
            }
        }
        , "chistofides-algorithm": {
            "tree": "Arborele creat prin aplicarea algoritmului lui Prim peste setul de date."
            , "odd-nodes": "GÄƒsirea nodurilor de grad impar cu scopul de a le uni douÄƒ cÃ¢te douÄƒ."
            , "matching": "Graful creat prin adÄƒugarea muchiilor rezultate prin algoritmul de matching."
        }
        , "optimization-algorithm": {
            "build-cycle": {
                "0": "Ciclul hamiltonian obÈ›inut Ã®n urma rulÄƒrii algoritmului euristic greedy:"
                , "1": "cu distanÈ›a"
            }
            , "optimize-cycle": {
                "no": "Peste ciclul hamiltonian creat nu se poate face nicio optimizare."
                , "yes": {
                    "0": "Prima optimizare gÄƒsitÄƒ transformÄƒ ciclul astfel. Din muchiile"
                    , "1": "È™i" 
                    , "2": "se aleg alte douÄƒ muchii"
                    , "3": "Ciclul devine "
                    , "4": "È™i soluÈ›ia devine"
                }
            }
        }
    }
    , "sidenav": {
        "general": "Prezentare generalÄƒ",
        "variations": "VariaÈ›ii",
        "asymmetric-tsp": "TSP asimetric",
        "multiple-visits-tsp": "TSP cu vizitari multiple",
        "max-tsp": "Max TSP",
        "metric-tsp": "Metric TSP",
        "exact-algorithms": "Algoritmi exacÈ›i",
        "dynamic-programming": "Programare dinamicÄƒ",
        "branch-and-bound": "Branch and bound",
        "approximation-algorithms": "Algoritmi de aproximare",
        "chistofides-algorithm": "Alg lui Christofides",
        "heuristic-algorithms": "Algoritmi euristici",
        "farthest-insertion": "Farthest Insertion",
        "nearest-insertion": "Nearest Insertion",
        "cheapest-insertion": "Cheapest Insertion",
        "nearest-neighbor": "Nearest Neighbor",
        "2-opt": "Algoritmul 2-OPT",
        "3-opt": "Algoritmul 3-OPT",
        "input-class": "Clasa Input",
        "double-tree-algorithm": "Alg arborelui dublu"
    }
    , "carousel": {
        "current-node": "Nod curent",
        "path": "Drum",
        "cicle": "Ciclu",
        "previous": "Precedent",
        "next": "UrmÄƒtorul",
        "reset": "ReseteazÄƒ",
        "nodes": "Noduri",
        "neighbours": "Vecini", 
        "start-node": "Nod de start"
        ,"farthest-node": "Nodul cel mai Ã®ndepÄƒrtat de ciclu este ales"
        , "distance-node-cycle": "DistanÈ›a de la nod la ciclu"
        , "positions-insert-node": "PoziÈ›iile pe care se poate introduce nodul "
        , "index": "Index"
        , "edge": "Muchie"
        , "growth": "CreÈ™tere"
        , "min-growth": "CreÈ™terea minimÄƒ a soluÈ›ia ciclului"
        , "insertion-position": "Nodul se insereazÄƒ Ã®ntre nodurile"
        , "solution-cycle": "SoluÈ›ie ciclu"
        , "distance-actualization": "Actualizarea distanÈ›elor minime pÃ¢nÄƒ la ciclu"
        , "unvisited-node": "Nod nevizitat"
        , "new-inserted-node": "Nod nou introdus"
        , "matrix-distance": "DistanÈ›Äƒ din matrice "
        , "min-distance": "DistanÈ›Äƒ minimÄƒ"
        , "is-actualizate": "Se actualizeazÄƒ"
        , "min-distances-unvisited-nodes-cycle": "DistanÈ›ele minime de la nodurile nevizitate pÃ¢nÄƒ la ciclu"
        , "nearest-node": "Nodul cel mai apropiat de ciclu este ales"
        , "chosen-node": "Nodul ales"
        , "node-with-min-growth": "Cu creÈ™terea minimÄƒ a soluÈ›iei ciclului"
        , "cycle-node": "Nodul din ciclu"
        , "set": "Se seteazÄƒ"
        , "solution": "SoluÈ›ie"
        , "distance": "DistanÈ›Äƒ"
        , "with-distance-from-node": "Cu distanÈ›a de la nodul curent"
        , "minimum": "minimÄƒ"
        , "go-to-start-node": "Ãntoarcere la nodul de start"
        , "edge-distance": "DistanÈ›a muchiei"
        , "bb-nodes-matrix": "Matrice redusÄƒ corespunzÄƒtoare nodului"
        , "bb-reduction-cost": "Cost reducere"
        , "bb-f-start-node": "f rÄƒdÄƒcinÄƒ "
        , "bb-start-node": "Nod pÄƒrinte"
        , "bb-start-text": "La primul pas se reduce matricea de distanÈ›e È™i costul reducerii se seteazÄƒ ca valoarea f a rÄƒdÄƒcinii"
        , "bb-remove-subtrees": "La Ã®ntoarcere sunt eliminaÈ›i subarborii pentru cÄƒ au limita mai mare decÃ¢t "
        , "distances-matrix": "Matrice de distanÈ›e"
        , "start-matrix": "Matrice pÄƒrinte"

        , "example-eulerian-cycle": "Exemplu pas cu pas Ã®n care se rezolvÄƒ problema determinÄƒrii ciclului hamiltonian pe baza determinÄƒrii ciclului eulerian"
        , "example-branch-and-bound": "Exemplu de rezolvare folosind strategia discutatÄƒ"
        , "example-farthest-insertion": "Exemplu pas cu pas pe baza algoritmului farthest insertion"
        , "example-nearest-insertion": "Exemplu pas cu pas pe baza algoritmului nearest insertion"
        , "example-cheapest-insertion": "Exemplu pas cu pas pe baza algoritmului cheapest insertion"
        , "example-nearest-neighbor": "Exemplu pas cu pas pe baza algoritmului nearest neighbor"
        , "instructions": {
            "green": "VERDE: nodurile È™i muchiile ce fac parte din ciclul final"
            , "orange": "PORTOCALIU:  muchiile de lungime minimÄƒ ce leagÄƒ fiecare nod nevizitat de ciclu"
            , "grey": "GRI: noduri nevizitate È™i toate muchiile ce nu se Ã®ncadreazÄƒ la verde È™i portocaliu"
            , "growth": "CreÈ™terea obÈ›inutÄƒ prin adÄƒugarea lui k Ã®ntre a È™i b: D[a, k] + D[k, b] - D[a, b]"
        }
    }
}